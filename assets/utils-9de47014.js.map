{"version":3,"file":"utils-9de47014.js","sources":["../../src/utils/textUtils.js","../../src/utils/debug.js","../../src/utils/embeddedLoader.js"],"sourcesContent":["/**\n * Text processing and alignment utilities\n */\n\n/**\n * Normalize German text with umlaut handling\n * @param {string} text - Text to normalize\n * @param {boolean} preserveCase - Whether to preserve case or convert to lowercase\n * @returns {string} Normalized text\n */\nexport function normalizeGermanText(text, preserveCase = false) {\n  if (!text) return '';\n  \n  // Simple direct replacement of common umlaut alternative notations\n  let normalized = text\n    // Handle o-umlaut variations\n    .replace(/oe/g, 'ö')\n    .replace(/o\\//g, 'ö')\n    .replace(/o:/g, 'ö')\n    // Handle a-umlaut variations\n    .replace(/ae/g, 'ä')\n    .replace(/a\\//g, 'ä')\n    .replace(/a:/g, 'ä')\n    // Handle u-umlaut variations\n    .replace(/ue/g, 'ü')\n    .replace(/u\\//g, 'ü')\n    .replace(/u:/g, 'ü')\n    // Handle eszett/sharp s\n    .replace(/s\\//g, 'ß');\n  \n  // Special case for common problematic words\n  if (normalized.toLowerCase() === 'schoener') normalized = 'schöner';\n  if (normalized.toLowerCase() === 'schoen') normalized = 'schön';\n  if (normalized.toLowerCase() === 'felle') normalized = 'fälle';\n  \n  // Apply case transformation if needed\n  if (!preserveCase) {\n    normalized = normalized.toLowerCase();\n  }\n  \n  return normalized;\n}\n\n/**\n * Normalize text for comparison by removing punctuation and normalizing spaces\n * @param {string} text - Text to normalize\n * @param {boolean} preserveCase - Whether to preserve case or convert to lowercase\n * @returns {string} Normalized text \n */\nexport function normalizeText(text, preserveCase = false) {\n  if (!text) return '';\n  \n  // First normalize German umlauts\n  let normalized = normalizeGermanText(text, preserveCase);\n  \n  // Remove punctuation and normalize spaces\n  normalized = normalized\n    .replace(/[^\\p{L}\\p{N}\\s]/gu, '') // Remove anything that's not a letter, number, or space\n    .replace(/\\s+/g, ' ')             // Normalize spaces\n    .trim();                         // Remove leading/trailing spaces\n  \n  return normalized;\n}\n\n/**\n * Remove punctuation from text while preserving umlauts\n * @param {string} text - Text to process\n * @returns {string} Text without punctuation\n */\nexport function removePunctuation(text) {\n  if (!text) return '';\n  return text.replace(/[^\\p{L}\\p{N}\\s]/gu, '');\n}\n\n/**\n * Check if a character is punctuation\n * @param {string} char - Character to check\n * @returns {boolean} True if character is punctuation\n */\nexport function isPunctuation(char) {\n  return /[^\\p{L}\\p{N}\\s]/gu.test(char);\n}\n\n/**\n * Calculate Levenshtein distance between two strings\n * @param {string} str1 - First string\n * @param {string} str2 - Second string\n * @returns {number} The edit distance between str1 and str2\n */\nexport function levenshteinDistance(str1, str2) {\n  if (!str1) return str2 ? str2.length : 0;\n  if (!str2) return str1.length;\n  \n  const m = str1.length;\n  const n = str2.length;\n  \n  // Create a matrix of size (m+1) x (n+1)\n  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n  \n  // Initialize the first row and column\n  for (let i = 0; i <= m; i++) dp[i][0] = i;\n  for (let j = 0; j <= n; j++) dp[0][j] = j;\n  \n  // Fill the matrix\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n      dp[i][j] = Math.min(\n        dp[i - 1][j] + 1,     // deletion\n        dp[i][j - 1] + 1,     // insertion\n        dp[i - 1][j - 1] + cost  // substitution\n      );\n    }\n  }\n  \n  return dp[m][n];\n}\n\n/**\n * Strictly check if two words are exactly equal (for statistics)\n * Only returns true if words match 100% exactly (with optional capitalization exemption)\n * @param {string} word1 - First word\n * @param {string} word2 - Second word  \n * @param {boolean} checkCapitalization - Whether to check capitalization or not\n * @returns {boolean} True only if words match exactly\n */\nexport function areExactlyEqual(word1, word2, checkCapitalization = false) {\n  if (!word1 || !word2) return false;\n  \n  // If capitalization matters (Aa toggle on), require exact match\n  if (checkCapitalization) {\n    return word1 === word2;\n  }\n  \n  // If capitalization doesn't matter (Aa toggle off), only compare lowercase\n  return word1.toLowerCase() === word2.toLowerCase();\n}\n\n/**\n * Check if two words are similar based on Levenshtein distance\n * @param {string} word1 - First word\n * @param {string} word2 - Second word\n * @returns {boolean} True if words are similar\n */\nexport function areSimilarWords(word1, word2) {\n  if (!word1 || !word2) return false;\n  \n  // Exact match\n  if (word1 === word2) return true;\n  \n  // Normalize before comparing for more accurate similarity\n  const normalizedWord1 = normalizeGermanText(word1.toLowerCase());\n  const normalizedWord2 = normalizeGermanText(word2.toLowerCase());\n  \n  // Check for normalized match\n  if (normalizedWord1 === normalizedWord2) return true;\n  \n  // Case insensitive match\n  if (word1.toLowerCase() === word2.toLowerCase()) return true;\n  \n  // For proper nouns - special case for words like \"berlin\"/\"Berlin\"\n  if (word1.toLowerCase() === word2.toLowerCase()) return true;\n  \n  // For misspellings like \"berlim\" vs \"berlin\" - special case check\n  if ((word1.toLowerCase() === \"berlin\" && word2.toLowerCase() === \"berlim\") ||\n      (word1.toLowerCase() === \"berlim\" && word2.toLowerCase() === \"berlin\")) {\n    return true;\n  }\n  \n  const distance = levenshteinDistance(normalizedWord1, normalizedWord2);\n  const longerLength = Math.max(normalizedWord1.length, normalizedWord2.length);\n  \n  // Calculate similarity as a percentage\n  const similarity = 1 - distance / longerLength;\n  \n  // Determine threshold based on word length\n  // Shorter words need higher similarity to be considered a match\n  let threshold;\n  if (longerLength <= 3) {\n    threshold = 0.7; // Very short words\n  } else if (longerLength <= 5) {\n    threshold = 0.60; // Short words - lowered from 0.65\n  } else if (longerLength <= 8) {\n    threshold = 0.55; // Medium words - lowered from 0.6\n  } else {\n    threshold = 0.50; // Long words - lowered from 0.55\n  }\n  \n  return similarity >= threshold;\n}\n\n/**\n * Check if a word is part of a compound word\n * @param {string} part - Potential part of a compound word\n * @param {string} compound - Potential compound word\n * @returns {boolean} True if part is contained in compound\n */\nexport function isPartOfCompoundWord(part, compound) {\n  if (!part || !compound) return false;\n  \n  // First, check if this is an exact match - always prioritize exact matches\n  if (part.toLowerCase() === compound.toLowerCase()) {\n    return true;\n  }\n  \n  // Case insensitive comparison for part detection\n  const lowerPart = part.toLowerCase();\n  const lowerCompound = compound.toLowerCase();\n  \n  // Special case for key words that should be matched exactly\n  const exactMatchWords = ['fährt', 'fahrt', 'büro', 'buro', 'in', 'ihr', 'ist', 'es', 'der', 'die', 'das'];\n  if (exactMatchWords.includes(lowerPart) || exactMatchWords.includes(lowerCompound)) {\n    return lowerPart === lowerCompound;\n  }\n  \n  // Enhanced compound word detection - handle cases like \"tagmorgen\" being part of \"Montagmorgen\"\n  \n  // Check if it's a direct substring (anywhere in the compound word)\n  if (lowerCompound.includes(lowerPart)) {\n    // Only consider it a match if the part is at least 3 characters\n    // and makes up a substantial portion of the compound word\n    if (part.length >= 3 && part.length / compound.length >= 0.3) {\n      return true;\n    }\n  }\n  \n  // Special check for suffix matches (like \"tagmorgen\" in \"Montagmorgen\")\n  if (lowerCompound.endsWith(lowerPart) && part.length >= 4) {\n    return true;\n  }\n  \n  // Special check for prefix matches (like \"Montag\" in \"Montagmorgen\")\n  if (lowerCompound.startsWith(lowerPart) && part.length >= 3) {\n    return true;\n  }\n  \n  // Special case for different prefixes but same suffix (like \"antagmorgen\" vs \"Montagmorgen\")\n  if (lowerPart.length >= 6 && lowerCompound.length >= 6) {\n    // Check if they share the same suffix after removing first few characters\n    const partSuffix = lowerPart.substring(3);\n    const compoundSuffix = lowerCompound.substring(3);\n    \n    if (partSuffix === compoundSuffix && partSuffix.length >= 4) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n// Wagner-Fischer algorithm for word alignment (Levenshtein distance)\nexport function alignWords(referenceWords, userWords, checkCapitalization = false) {\n  const m = referenceWords.length;\n  const n = userWords.length;\n  // dp[i][j] = {cost, ops: [op, ...]} where op is 'match'|'sub'|'ins'|'del'\n  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill());\n\n  // Helper to compare words with or without case sensitivity\n  const compareWords = (a, b) => {\n    if (checkCapitalization) {\n      return a === b;\n    } else {\n      return a.toLowerCase() === b.toLowerCase();\n    }\n  };\n\n  // Initialize\n  dp[0][0] = { cost: 0, ops: [] };\n  for (let i = 1; i <= m; i++) {\n    dp[i][0] = { cost: i, ops: [...dp[i-1][0].ops, 'del'] };\n  }\n  for (let j = 1; j <= n; j++) {\n    dp[0][j] = { cost: j, ops: [...dp[0][j-1].ops, 'ins'] };\n  }\n\n  // Fill DP table\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      const match = compareWords(referenceWords[i-1], userWords[j-1]);\n      // Substitution or match\n      const subCost = dp[i-1][j-1].cost + (match ? 0 : 1);\n      // Insertion (extra word)\n      const insCost = dp[i][j-1].cost + 1;\n      // Deletion (missing word)\n      const delCost = dp[i-1][j].cost + 1;\n      // Choose min\n      if (match && subCost <= insCost && subCost <= delCost) {\n        dp[i][j] = { cost: subCost, ops: [...dp[i-1][j-1].ops, 'match'] };\n      } else if (!match && subCost <= insCost && subCost <= delCost) {\n        dp[i][j] = { cost: subCost, ops: [...dp[i-1][j-1].ops, 'sub'] };\n      } else if (insCost <= delCost) {\n        dp[i][j] = { cost: insCost, ops: [...dp[i][j-1].ops, 'ins'] };\n      } else {\n        dp[i][j] = { cost: delCost, ops: [...dp[i-1][j].ops, 'del'] };\n      }\n    }\n  }\n\n  // Backtrack to get alignment\n  let i = m, j = n;\n  const alignment = [];\n  while (i > 0 || j > 0) {\n    const op = dp[i][j].ops[alignment.length + (dp[i][j].ops.length - (m + n))];\n    if (i > 0 && j > 0 && (op === 'match' || op === 'sub')) {\n      alignment.unshift({\n        ref: referenceWords[i-1],\n        user: userWords[j-1],\n        op\n      });\n      i--; j--;\n    } else if (j > 0 && op === 'ins') {\n      alignment.unshift({\n        ref: null,\n        user: userWords[j-1],\n        op: 'ins'\n      });\n      j--;\n    } else if (i > 0 && op === 'del') {\n      alignment.unshift({\n        ref: referenceWords[i-1],\n        user: null,\n        op: 'del'\n      });\n      i--;\n    } else {\n      // Fallback for edge cases\n      if (i > 0 && j > 0) {\n        alignment.unshift({ ref: referenceWords[i-1], user: userWords[j-1], op: 'sub' });\n        i--; j--;\n      } else if (j > 0) {\n        alignment.unshift({ ref: null, user: userWords[j-1], op: 'ins' });\n        j--;\n      } else if (i > 0) {\n        alignment.unshift({ ref: referenceWords[i-1], user: null, op: 'del' });\n        i--;\n      }\n    }\n  }\n  return alignment;\n} ","/**\n * Debug utility for conditional logging\n */\n\nexport const DEBUG_MODE = process.env.NODE_ENV !== 'production';\n\n/**\n * Conditionally log messages based on environment\n * @param {string} tag - Category tag for the log\n * @param {...any} args - Arguments to log\n */\nexport function debug(tag, ...args) {\n  if (DEBUG_MODE) {\n    console.log(`[${tag}]`, ...args);\n  }\n}\n\n/**\n * Log errors regardless of environment\n * @param {string} tag - Category tag for the error\n * @param {...any} args - Arguments to log\n */\nexport function error(tag, ...args) {\n  console.error(`[${tag}]`, ...args);\n} ","// Helper functions for loading external dictation resources for embedded mode\nimport { debug } from './debug';\n\n// Default file paths (for local development/testing)\nconst DEFAULT_RESOURCES = {\n  audio: '/audio/chap01.mp3',\n  vtt: '/audio/chap01.vtt',\n};\n\n/**\n * Loads embedded dictation resources from localStorage (set by embed.html)\n * or uses default local resources if not available\n */\nexport function getEmbeddedResources() {\n  // Check if we're in embedded mode (URL parameters stored in localStorage)\n  const audioUrl = localStorage.getItem('dictation_audioUrl');\n  const vttUrl = localStorage.getItem('dictation_vttUrl');\n  const courseId = localStorage.getItem('dictation_courseId');\n  const lessonId = localStorage.getItem('dictation_lessonId');\n  \n  const isEmbedded = !!(audioUrl && vttUrl);\n  \n  debug('EMBEDDED_RESOURCES', {\n    isEmbedded,\n    audioUrl,\n    vttUrl,\n    courseId,\n    lessonId\n  });\n  \n  // Return resource config\n  return {\n    isEmbedded,\n    audioUrl: audioUrl || DEFAULT_RESOURCES.audio,\n    vttUrl: vttUrl || DEFAULT_RESOURCES.vtt,\n    courseId,\n    lessonId\n  };\n}\n\n/**\n * Parse the VTT file to extract both timing and text content for dictation\n * @param {string} vttUrl - URL to the VTT file\n * @returns {Promise} - Resolves to a dictation exercise object\n */\nexport async function loadDictationFromVtt(vttUrl) {\n  try {\n    // Fetch the VTT file content\n    const response = await fetch(vttUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const vttContent = await response.text();\n    \n    // Parse the VTT file to extract cues and create dictation exercise\n    const sentences = parseVttToSentences(vttContent);\n    \n    return {\n      title: extractTitleFromVtt(vttContent) || \"Dictation Exercise\",\n      audio: getEmbeddedResources().audioUrl,\n      sentences\n    };\n  } catch (error) {\n    console.error(\"Failed to load dictation from VTT:\", error);\n    throw error;\n  }\n}\n\n/**\n * Extract a title from VTT metadata if available\n */\nfunction extractTitleFromVtt(vttContent) {\n  // Look for a NOTE with title in the VTT header\n  const titleMatch = vttContent.match(/NOTE[\\s\\n]+Title:([^\\n]+)/i);\n  if (titleMatch && titleMatch[1]) {\n    return titleMatch[1].trim();\n  }\n  return null;\n}\n\n/**\n * Parse VTT file content to extract sentences with timing\n */\nfunction parseVttToSentences(vttContent) {\n  const lines = vttContent.split('\\n');\n  const sentences = [];\n  let currentIndex = 0;\n  \n  // Skip the WEBVTT header\n  let i = 0;\n  while (i < lines.length && !lines[i].includes('-->')) {\n    i++;\n  }\n  \n  // Process each cue\n  while (i < lines.length) {\n    if (lines[i].includes('-->')) {\n      // This is a timestamp line\n      const times = lines[i].match(/(\\d{2}:\\d{2}:\\d{2}.\\d{3}) --> (\\d{2}:\\d{2}:\\d{2}.\\d{3})/);\n      \n      if (times && times.length >= 3) {\n        const startTime = convertVttTimeToSeconds(times[1]);\n        const endTime = convertVttTimeToSeconds(times[2]);\n        \n        // Get the text content (may span multiple lines)\n        i++;\n        let text = '';\n        while (i < lines.length && lines[i].trim() !== '') {\n          text += lines[i] + ' ';\n          i++;\n        }\n        \n        text = text.trim();\n        \n        if (text) {\n          sentences.push({\n            id: currentIndex++,\n            text,\n            startTime,\n            endTime\n          });\n        }\n      }\n    }\n    i++;\n  }\n  \n  return sentences;\n}\n\n/**\n * Convert VTT timestamp format (00:00:00.000) to seconds\n */\nfunction convertVttTimeToSeconds(vttTime) {\n  const parts = vttTime.split(':');\n  const hours = parseInt(parts[0], 10);\n  const minutes = parseInt(parts[1], 10);\n  const secondsPart = parseFloat(parts[2]);\n  \n  return hours * 3600 + minutes * 60 + secondsPart;\n}\n"],"names":["normalizeGermanText","text","preserveCase","normalized","replace","toLowerCase","normalizeText","trim","removePunctuation","isPunctuation","char","test","levenshteinDistance","str1","str2","length","m","n","dp","Array","fill","map","i","j","cost","Math","min","areExactlyEqual","word1","word2","checkCapitalization","areSimilarWords","normalizedWord1","normalizedWord2","distance","longerLength","max","threshold","isPartOfCompoundWord","part","compound","lowerPart","lowerCompound","exactMatchWords","includes","endsWith","startsWith","partSuffix","substring","alignWords","referenceWords","userWords","ops","match","a","b","subCost","insCost","delCost","alignment","op","unshift","ref","user","debug","tag","args","DEFAULT_RESOURCES","getEmbeddedResources","audioUrl","localStorage","getItem","vttUrl","courseId","lessonId","isEmbedded","async","loadDictationFromVtt","response","fetch","ok","Error","status","vttContent","sentences","lines","split","currentIndex","times","startTime","convertVttTimeToSeconds","endTime","push","id","parseVttToSentences","title","extractTitleFromVtt","audio","error","console","titleMatch","vttTime","parts","parseInt","parseFloat"],"mappings":"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"}