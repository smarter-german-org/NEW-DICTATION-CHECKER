{"version":3,"file":"index-9993b2de.js","sources":["../../node_modules/react/cjs/react-jsx-runtime.production.min.js","../../node_modules/react/jsx-runtime.js","../../node_modules/react-dom/client.js","../../src/components/AudioPlayer.jsx","../../src/components/ConfirmDialog.jsx","../../src/components/DictationFeedback.jsx","../../src/components/DictationTool.jsx","../../src/responsive/ResponsiveContext.jsx","../../src/responsive/constants.js","../../src/components/mobile/MobileGestureHandler.jsx","../../src/components/DictationToolWithRef.jsx","../../src/components/mobile/MobileAudioPlayer.jsx","../../src/components/mobile/MobileDictationTool.jsx","../../src/utils/embeddedLoader.js","../../src/components/mobile/MobileWrapper.jsx","../../src/App.jsx","../../src/main.jsx"],"sourcesContent":["/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","import React, { useState, useEffect, useRef, forwardRef, useImperativeHandle } from 'react';\nimport './AudioPlayer.css';\nimport './mobile/MobileResponsiveControls.css';\n\nconst AudioPlayer = forwardRef(({ \n  audioSrc, \n  onEnded, \n  onPlayStateChange,\n  checkCapitalization = false,\n  onToggleCapitalization = () => {},\n  onPrevious = () => {},\n  onNext = () => {},\n  onCancel = () => {},\n  onRepeat = () => {}\n}, ref) => {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n  \n  // Track current sentence boundaries using refs\n  const sentenceEndTimeRef = useRef(null);\n  const sentenceStartTimeRef = useRef(0);  // Add start time tracking\n  // Add flag to prevent multiple callbacks\n  const endEventProcessedRef = useRef(false);\n  \n  const audioRef = useRef(null);\n  const progressRef = useRef(null);\n  \n  // Handle audio source change\n  useEffect(() => {\n    setIsPlaying(false);\n    setCurrentTime(0);\n    setDuration(0);\n    setIsLoaded(false);\n    \n    // Reset audio element\n    if (audioRef.current) {\n      audioRef.current.pause();\n      audioRef.current.currentTime = 0;\n      audioRef.current.load();\n    }\n  }, [audioSrc]);\n  \n  // Expose audio methods to parent component\n  useImperativeHandle(ref, () => ({\n    play: () => {\n      if (audioRef.current && isLoaded) {\n        endEventProcessedRef.current = false;\n        audioRef.current.play();\n      }\n    },\n    pause: () => {\n      if (audioRef.current) {\n        audioRef.current.pause();\n      }\n    },\n    stop: () => {\n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current.currentTime = 0;\n      }\n    },\n    seekTo: (timeInSeconds) => {\n      if (audioRef.current && isLoaded) {\n        // Store the start time when seeking to a new sentence\n        sentenceStartTimeRef.current = timeInSeconds;\n        audioRef.current.currentTime = timeInSeconds;\n        setCurrentTime(timeInSeconds);\n        // Reset the processed flag when seeking to a new position\n        endEventProcessedRef.current = false;\n        \n        // When seeking to a new sentence start, we need to know where it ends\n        // This will be set by the parent component through the setCurrentSentenceEndTime method\n        return true;\n      }\n      return false;\n    },\n    setCurrentSentenceEndTime: (endTimeInSeconds) => {\n      // Store the end time of the current sentence\n      sentenceEndTimeRef.current = endTimeInSeconds;\n      // Reset the processed flag when setting a new end time\n      endEventProcessedRef.current = false;\n      console.log(\"Set sentence end time to:\", endTimeInSeconds);\n    },\n    getCurrentTime: () => {\n      return audioRef.current ? audioRef.current.currentTime : 0;\n    },\n    getDuration: () => {\n      return audioRef.current ? audioRef.current.duration : 0;\n    },\n    repeatSentence: () => {\n      if (audioRef.current && isLoaded) {\n        // Reset the processed flag\n        endEventProcessedRef.current = false;\n        \n        // Use the stored sentence start time\n        audioRef.current.currentTime = sentenceStartTimeRef.current;\n        \n        // The end time should still be valid from the previous setCurrentSentenceEndTime call\n        if (sentenceEndTimeRef.current === null) {\n          console.warn('No end time set for sentence repeat');\n        }\n        \n        // Start playback\n        audioRef.current.play();\n        return true;\n      }\n      return false;\n    }\n  }));\n  \n  // Format time to MM:SS\n  const formatTime = (seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;\n  };\n  \n  const handlePlayPause = () => {\n    if (!isLoaded) return;\n    \n    if (isPlaying) {\n      audioRef.current.pause();\n      if (onPlayStateChange) {\n        onPlayStateChange('paused');\n      }\n    } else {\n      // If we're not playing, start playback\n      if (onPlayStateChange) {\n        // Signal that we're starting playback\n        onPlayStateChange('playing');\n      }\n      \n      // Start playback\n      audioRef.current.play();\n    }\n  };\n  \n  const handleRewind = () => {\n    if (onPrevious) {\n      onPrevious();\n    } else {\n      if (!isLoaded) return;\n      audioRef.current.currentTime = Math.max(0, audioRef.current.currentTime - 5);\n    }\n  };\n  \n  const handleForward = () => {\n    if (onNext) {\n      onNext();\n    } else {\n      if (!isLoaded) return;\n      audioRef.current.currentTime = Math.min(\n        audioRef.current.duration,\n        audioRef.current.currentTime + 5\n      );\n    }\n  };\n\n  const handleReset = () => {\n    if (!isLoaded) return;\n    audioRef.current.currentTime = 0;\n  };\n  \n  const handleRepeatSentence = () => {\n    if (!isLoaded) return;\n    \n    // Stop any current playback first\n    if (audioRef.current) {\n      audioRef.current.pause();\n    }\n    \n    // Reset flags\n    endEventProcessedRef.current = false;\n    \n    // Use the stored sentence start time\n    audioRef.current.currentTime = sentenceStartTimeRef.current;\n    \n    // Make sure we still have the end time set\n    if (sentenceEndTimeRef.current) {\n      // Start playback\n      audioRef.current.play();\n      setIsPlaying(true);\n    } else {\n      console.warn('No end time set for sentence repeat');\n    }\n  };\n  \n  const handleProgressClick = (e) => {\n    if (!isLoaded || !progressRef.current) return;\n    \n    const rect = progressRef.current.getBoundingClientRect();\n    const pos = (e.clientX - rect.left) / rect.width;\n    audioRef.current.currentTime = pos * audioRef.current.duration;\n  };\n  \n  const handleTimeUpdate = () => {\n    if (audioRef.current) {\n      const currentAudioTime = audioRef.current.currentTime;\n      setCurrentTime(currentAudioTime);\n      \n      // Check if we've reached the end of the current sentence\n      if (sentenceEndTimeRef.current !== null && \n          currentAudioTime >= sentenceEndTimeRef.current && \n          !endEventProcessedRef.current) {  // Only process if not already handled\n        \n        console.log(\"Reached sentence end time:\", sentenceEndTimeRef.current, \"current time:\", currentAudioTime);\n        \n        // Mark as processed to prevent multiple callbacks\n        endEventProcessedRef.current = true;\n        \n        // Stop playback when we reach the end time\n        audioRef.current.pause();\n        setIsPlaying(false);\n        \n        // Call the onEnded callback to notify parent\n        if (onEnded) {\n          // Reset sentence end time\n          const prevEndTime = sentenceEndTimeRef.current;\n          sentenceEndTimeRef.current = null;\n          \n          // Small delay to ensure state is updated before callback\n          setTimeout(() => {\n            if (audioRef.current && Math.abs(audioRef.current.currentTime - prevEndTime) < 0.5) {\n              onEnded();\n            }\n          }, 50);\n        }\n      }\n    }\n  };\n  \n  const handleLoadedMetadata = () => {\n    if (audioRef.current) {\n      setDuration(audioRef.current.duration);\n      setIsLoaded(true);\n    }\n  };\n  \n  const handleAudioEnded = () => {\n    setIsPlaying(false);\n    \n    // Ensure playback is truly stopped\n    if (audioRef.current) {\n      audioRef.current.pause();\n    }\n    \n    if (onEnded) {\n      // Small delay to ensure state is updated before callback\n      setTimeout(() => {\n        onEnded();\n      }, 50);\n    }\n  };\n  \n  const handlePlayingState = () => {\n    const playing = audioRef.current && !audioRef.current.paused;\n    setIsPlaying(playing);\n    if (onPlayStateChange) onPlayStateChange(playing);\n  };\n  \n  const togglePlaybackSpeed = () => {\n    let newSpeed;\n    if (playbackSpeed === 1.0) {\n      newSpeed = 0.75;\n    } else if (playbackSpeed === 0.75) {\n      newSpeed = 0.5;\n    } else {\n      newSpeed = 1.0;\n    }\n    \n    // Set the playback rate immediately with the new value\n    if (audioRef.current) {\n      audioRef.current.playbackRate = newSpeed;\n    }\n    \n    // Update the state to reflect the new speed\n    setPlaybackSpeed(newSpeed);\n  };\n\n  // Check the cancel button implementation\n  const handleCancel = (e) => {\n    // Stop the event to prevent any bubbling issues\n    e.preventDefault();\n    e.stopPropagation();\n    \n    console.log(\"Cancel button clicked in AudioPlayer\");\n    \n    // Try the prop callback first\n    if (typeof onCancel === 'function') {\n      console.log(\"Calling onCancel prop\");\n      onCancel();\n    } \n    // Fallback - dispatch custom event\n    else {\n      console.log(\"Dispatching custom cancelDictation event\");\n      const cancelEvent = new CustomEvent('dictationCancel');\n      document.dispatchEvent(cancelEvent);\n    }\n  };\n  \n  return (\n    <div className=\"audio-player\">\n      <audio\n        ref={audioRef}\n        src={audioSrc}\n        onTimeUpdate={handleTimeUpdate}\n        onLoadedMetadata={handleLoadedMetadata}\n        onEnded={handleAudioEnded}\n        onPlay={handlePlayingState}\n        onPause={handlePlayingState}\n        loop={false}\n      />\n      \n      <div className=\"player-container\">\n        <div className=\"controls-left\">\n          <button \n            className=\"control-button\" \n            onClick={handleRewind}\n            disabled={!isLoaded}\n            title=\"Previous Sentence\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M15 18l-6-6 6-6\" />\n            </svg>\n          </button>\n          \n          <button \n            className=\"play-button\" \n            onClick={handlePlayPause}\n            disabled={!isLoaded}\n          >\n            {isPlaying ? (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n                <rect x=\"6\" y=\"4\" width=\"4\" height=\"16\" />\n                <rect x=\"14\" y=\"4\" width=\"4\" height=\"16\" />\n              </svg>\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n                <polygon points=\"5,3 19,12 5,21\" />\n              </svg>\n            )}\n          </button>\n          \n          <button \n            className=\"control-button\" \n            onClick={handleForward}\n            disabled={!isLoaded}\n            title=\"Next Sentence\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n              <path d=\"M9 18l6-6-6-6\" />\n            </svg>\n          </button>\n        </div>\n        \n        <div className=\"progress-wrapper\">\n          <div className=\"progress-bar-container\">\n            <div \n              className=\"progress-bar\" \n              ref={progressRef}\n              onClick={handleProgressClick}\n            >\n              <div \n                className=\"progress-fill\" \n                style={{ width: `${(currentTime / duration) * 100 || 0}%` }}\n              ></div>\n            </div>\n            <div className=\"time-display\">\n              {formatTime(currentTime)} / {formatTime(duration)}\n            </div>\n          </div>\n          \n          <div className=\"controls-right\">\n            <button \n              className={`option-toggle ${checkCapitalization ? 'active' : ''}`}\n              onClick={onToggleCapitalization}\n              title={`Case Sensitivity: ${checkCapitalization ? 'Strict (Hard Mode)' : 'Relaxed (Normal Mode)'}`}\n            >\n              Aa\n            </button>\n            \n            <button \n              className=\"option-toggle\"\n              onClick={onRepeat}\n              title=\"Repeat Sentence\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n                <path d=\"M23 4v6h-6\" />\n                <path d=\"M1 20v-6h6\" />\n                <path d=\"M3.51 9a9 9 0 0 1 14.85-3.36L23 10\" />\n                <path d=\"M20.49 15a9 9 0 0 1-14.85 3.36L1 14\" />\n              </svg>\n            </button>\n            \n            <button onClick={togglePlaybackSpeed} className=\"playback-speed-button\">\n              {playbackSpeed === 1.0 ? '100%' : playbackSpeed === 0.75 ? '75%' : '50%'}\n            </button>\n            \n            <button \n              className=\"cancel-button\"\n              onClick={handleCancel}\n              title=\"Cancel exercise\"\n            >\n              <span>âœ•</span>\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n});\n\nexport default AudioPlayer;","import React from 'react';\nimport './ConfirmDialog.css';\n\nconst ConfirmDialog = ({ \n  isOpen, \n  title = 'Confirm Action', \n  message = 'Are you sure?', \n  confirmText = 'Confirm', \n  cancelText = 'Cancel',\n  onConfirm, \n  onCancel\n}) => {\n  if (!isOpen) return null;\n  \n  return (\n    <div className=\"confirm-dialog-overlay\">\n      <div className=\"confirm-dialog\">\n        <h3 className=\"confirm-dialog-title\">{title}</h3>\n        <p className=\"confirm-dialog-message\">{message}</p>\n        \n        <div className=\"confirm-dialog-buttons\">\n          <button \n            className=\"confirm-dialog-button confirm\"\n            onClick={onConfirm}\n          >\n            {confirmText}\n          </button>\n          <button \n            className=\"confirm-dialog-button cancel\" \n            onClick={onCancel}\n          >\n            {cancelText}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ConfirmDialog; ","import React, { useMemo, useState, useRef, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport './DictationFeedback.css';\nimport './mobile/MobileFeedback.css';\nimport { \n  alignWords, \n  normalizeGermanText, \n  levenshteinDistance,\n  areSimilarWords,\n  areExactlyEqual\n} from '../utils/textUtils';\nimport { debug } from '../utils/debug';\n\n// Tooltip component that will be rendered at the document level\nconst Tooltip = ({ content, position, onClose }) => {\n  return ReactDOM.createPortal(\n    <div \n      className=\"word-tooltip\" \n      style={{ \n        left: `${position.left}px`, \n        top: `${position.top}px`\n      }}\n      onClick={onClose}\n    >\n      {content}\n    </div>,\n    document.body\n  );\n};\n\nconst DictationFeedback = ({ \n  dictationResults, \n  sentenceResults, \n  totalTime = 0, \n  onRestart \n}) => {\n  debug('RENDER_FEEDBACK', dictationResults, sentenceResults);\n\n  // State for showing tooltips on word click\n  const [activeTooltip, setActiveTooltip] = useState(null);\n  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });\n  const [tooltipContent, setTooltipContent] = useState('');\n  \n  // Check if a word potentially contains an umlaut or alternative notation\n  const hasUmlautPattern = (word) => {\n    if (!word) return false;\n    \n    // Check for actual umlauts\n    if (/[Ã¤Ã¶Ã¼Ã„Ã–ÃœÃŸ]/.test(word)) return true;\n    \n    // Check for common alternative notations\n    if (/a\\/|ae|a:|o\\/|oe|o:|u\\/|ue|u:|s\\//.test(word)) return true;\n    \n    return false;\n  };\n  \n  // Calculate similarity as percentage (0-1)\n  const calculateSimilarity = (word1, word2) => {\n    if (!word1 || !word2) return 0;\n    \n    // Normalize both words for German umlauts\n    const normalizedWord1 = normalizeGermanText(word1.toLowerCase());\n    const normalizedWord2 = normalizeGermanText(word2.toLowerCase());\n    \n    // If after normalization they match exactly, return perfect score\n    if (normalizedWord1 === normalizedWord2) return 1.0;\n    \n    // Calculate distance with umlaut-aware Levenshtein\n    const distance = levenshteinDistance(normalizedWord1, normalizedWord2);\n    const maxLength = Math.max(normalizedWord1.length, normalizedWord2.length);\n    \n    // Calculate base similarity score\n    let similarity = 1 - (distance / maxLength);\n    \n    // Boost scores for words with umlaut patterns\n    if (hasUmlautPattern(word1) || hasUmlautPattern(word2)) {\n      similarity = Math.min(1.0, similarity * 1.2); // Boost by 20% but cap at 1.0\n    }\n    \n    return similarity;\n  };\n  \n  // Calculate statistics based on results\n  const stats = useMemo(() => {\n    debug('CALC_STATS', {\n      hasDictationResults: !!dictationResults,\n      sentenceResultsLength: sentenceResults?.length\n    });\n\n    const totalSentences = sentenceResults.length;\n    const completedSentences = sentenceResults.filter(Boolean).length;\n\n    // Count total words in the entire expected text\n    let totalWords = dictationResults.totalWordsInAllText || 0;\n    let completedWords = 0;\n    let correctWords = 0;\n    let incorrectWords = 0;\n\n    // Process the sentences that have been attempted\n    sentenceResults.forEach((result, index) => {\n      if (result) {\n        // Count words in the user's input\n        const actualWords = result.actual.split(/\\s+/).filter(Boolean);\n        const expectedWords = result.expected.split(/\\s+/).filter(Boolean);\n        \n        completedWords += actualWords.length;\n        \n        // When calculating stats, use STRICT matching for correct words\n        // This ensures words are only counted as correct if they match 100%\n        let tempCorrectWords = 0;\n        const matchedExpectedIndices = new Set();\n        \n        actualWords.forEach(actualWord => {\n          // Try to find a match among expected words\n          for (let i = 0; i < expectedWords.length; i++) {\n            if (matchedExpectedIndices.has(i)) continue; // Skip already matched words\n            \n            const expectedWord = expectedWords[i];\n            \n            // For statistics, use strict exact matching (100% match required)\n            // Only exception is capitalization when Aa toggle is off\n            if (areExactlyEqual(actualWord, expectedWord, dictationResults.checkCapitalization)) {\n              matchedExpectedIndices.add(i);\n              tempCorrectWords++;\n              break; // Found a match, move to next actual word\n            }\n          }\n        });\n        \n        correctWords += tempCorrectWords;\n        \n        // Incorrect words are those entered incorrectly (not missing words)\n        incorrectWords += (actualWords.length - tempCorrectWords);\n      }\n    });\n\n    // Calculate percentages\n    const percentageCompleted = totalWords > 0 ? (completedWords / totalWords) * 100 : 0;\n    const accuracyPercentage = completedWords > 0 ? (correctWords / completedWords) * 100 : 0;\n\n    const statsObj = {\n      totalWords,\n      completedWords,\n      correctWords,\n      incorrectWords,\n      percentageCompleted,\n      accuracyPercentage,\n      totalSentences,\n      completedSentences\n    };\n    \n    debug('STATS_CALCULATED', statsObj);\n    return statsObj;\n  }, [dictationResults, sentenceResults]);\n\n  // Format time from seconds to mm:ss\n  const formatTime = (seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;\n  };\n\n  // Global click handler to close tooltip when clicking anywhere else\n  useEffect(() => {\n    const handleGlobalClick = (e) => {\n      // Close tooltip when clicking anywhere except tooltip elements\n      if (activeTooltip && \n          !e.target.closest('.word-tooltip') && \n          !e.target.closest('.word-incorrect')) {\n        setActiveTooltip(null);\n      }\n    };\n    \n    document.addEventListener('click', handleGlobalClick);\n    return () => document.removeEventListener('click', handleGlobalClick);\n  }, [activeTooltip]);\n  \n  // Improved sentence-by-sentence comparison\n  const SentenceByLineComparison = () => {\n    return (\n      <div className=\"side-by-side-comparison\">\n        <div className=\"comparison-column\">\n          <h3>Your Text</h3>\n          <div className=\"text-container\">\n            {sentenceResults.map((result, sentenceIndex) => (\n              <div key={sentenceIndex} className=\"sentence-row\">\n                {result ? (\n                  <HighlightedUserSentence \n                    userText={result.actual} \n                    expectedText={result.expected}\n                    sentenceIndex={sentenceIndex}\n                  />\n                ) : (\n                  <div className=\"sentence-placeholder\">\n                    <span className=\"skipped-indicator\">Not attempted</span>\n                  </div>\n                )}\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  // Component to display user's sentence with proper highlighting and individual placeholders for missing words\n  const HighlightedUserSentence = ({ userText, expectedText, sentenceIndex }) => {\n    if (!userText) return <div className=\"empty-text\">(No text)</div>;\n    \n    // Ref to track positions of words\n    const wordRefs = useRef({});\n    \n    // Split both texts into words\n    const userWords = userText.split(/\\s+/).filter(Boolean);\n    const expectedWords = expectedText.split(/\\s+/).filter(Boolean);\n    \n    // Use the same alignment algorithm for consistent results\n    const alignment = alignWords(expectedWords, userWords, dictationResults.checkCapitalization);\n\n    // Helper function to find the best match for a word in the expected text\n    // This is ONLY used for tooltip content, not for alignment or statistics\n    const findBetterMatchForTooltip = (word) => {\n      if (!word) return null;\n      \n      let bestMatch = null;\n      let bestScore = 0;\n      \n      // First, check for exact matches (ignoring case)\n      for (const expectedWord of expectedWords) {\n        if (expectedWord.toLowerCase() === word.toLowerCase()) {\n          return expectedWord; // Return exact match immediately\n        }\n      }\n      \n      // Handle common typos with single character differences\n      for (const expectedWord of expectedWords) {\n        // If the lengths are similar (within 2 characters)\n        if (Math.abs(expectedWord.length - word.length) <= 2) {\n          // Calculate basic Levenshtein distance\n          const distance = levenshteinDistance(\n            expectedWord.toLowerCase(), \n            word.toLowerCase()\n          );\n          \n          // For very short words (3 chars or less), allow only 1 difference\n          // For longer words, allow up to 2 differences\n          const maxAllowedDistance = expectedWord.length <= 3 ? 1 : 2;\n          \n          if (distance <= maxAllowedDistance) {\n            return expectedWord;\n          }\n        }\n      }\n      \n      // Then look for similar words with higher threshold\n      for (const expectedWord of expectedWords) {\n        // Calculate similarity score\n        const similarity = calculateSimilarity(word, expectedWord);\n        \n        if (similarity > bestScore && similarity > 0.6) { // Increased threshold for more accuracy\n          bestScore = similarity;\n          bestMatch = expectedWord;\n        }\n      }\n      \n      return bestMatch;\n    };\n    \n    // Handle click on a word to show tooltip\n    const handleWordClick = (tooltipId, word) => {\n      if (activeTooltip === tooltipId) {\n        // Toggle off\n        setActiveTooltip(null);\n        return;\n      }\n      \n      const wordEl = wordRefs.current[tooltipId];\n      if (wordEl) {\n        const rect = wordEl.getBoundingClientRect();\n        \n        // Position tooltip using fixed positioning relative to viewport\n        setTooltipPosition({\n          left: rect.left + (rect.width / 2),\n          top: rect.top - 10\n        });\n        \n        // For tooltip content, always look for the best match for this word\n        const betterMatch = findBetterMatchForTooltip(word);\n        const tooltipText = betterMatch || 'Extra word';\n        \n        setTooltipContent(tooltipText);\n        setActiveTooltip(tooltipId);\n      }\n    };\n    \n    // Render elements based on alignment\n    const renderElements = alignment.map((pair, idx) => {\n      let className = '';\n      let tooltipId = `word-${sentenceIndex}-${idx}`;\n      let displayText = pair.user;\n      let isCorrect = false;\n      \n      // Use strict exact matching (100% match required) for visual display\n      // This matches the statistics calculation for consistency\n      if (pair.op === 'match') {\n        isCorrect = true;\n      } else if (pair.op === 'sub' && pair.ref && pair.user) {\n        // Use the same strict matching as statistics with areExactlyEqual\n        isCorrect = areExactlyEqual(pair.user, pair.ref, dictationResults.checkCapitalization);\n      }\n      \n      if (isCorrect) {\n        className = 'word-correct';\n        // When Aa is off, we still want to show proper capitalization\n        // So use the reference word (which has correct capitalization)\n        // But we still consider it correct\n        if (!dictationResults.checkCapitalization && pair.ref && pair.user) {\n          // If capitalization differs but words match case-insensitively\n          if (pair.ref.toLowerCase() === pair.user.toLowerCase() && \n              pair.ref !== pair.user) {\n            displayText = pair.ref; // Use properly capitalized version\n          }\n        }\n      } else if (pair.op === 'sub') {\n        className = 'word-incorrect';\n      } else if (pair.op === 'ins') {\n        className = 'word-incorrect';\n      } else if (pair.op === 'del') {\n        className = 'word-placeholder';\n        displayText = '_'.repeat(pair.ref.length); // Dynamic placeholder based on word length\n      }\n      \n      // Apply different styles based on whether the word is correct or not\n      const style = isCorrect ? \n        { color: 'var(--text-light)', textDecoration: 'none', backgroundColor: 'transparent' } : \n        {\n          color: 'var(--incorrect)',\n          textDecoration: pair.op === 'sub' || pair.op === 'ins' ? 'line-through' : 'none',\n          position: 'relative',\n          backgroundColor: 'rgba(255, 82, 82, 0.1)'\n        };\n      \n      return (\n        <span\n          key={idx}\n          className={className}\n          style={style}\n          onClick={!isCorrect && displayText !== '_'.repeat(pair.ref?.length || 0) ? \n            () => handleWordClick(tooltipId, displayText) : undefined}\n          ref={el => wordRefs.current[tooltipId] = el}\n        >\n          {displayText}\n        </span>\n      );\n    });      return (\n      <div className=\"user-sentence-wrapper\">\n        <div className=\"user-sentence\">\n          {renderElements.map((element, index) => (\n            <React.Fragment key={index}>\n              {element}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"dictation-feedback\" data-screen=\"results\">\n      <h2>Dictation Results</h2>\n      \n      {/* Add Score Display at the top */}\n      {dictationResults.score !== undefined && (\n        <div className=\"score-display\">\n          <div className=\"score-value\">{dictationResults.score}</div>\n          <div className=\"score-label\">Score</div>\n          \n          {/* Display hint penalty if hints were used */}\n          {dictationResults.maxHintLevelUsed > 0 && (\n            <div className=\"hint-penalty-info\">\n              <span className=\"hint-icon\">ðŸ’¡</span>\n              <span className=\"hint-text\">\n                Hint penalty: {Math.round((1 - dictationResults.hintPenaltyMultiplier) * 100)}%\n              </span>\n            </div>\n          )}\n        </div>\n      )}\n      \n      <div className=\"feedback-stats\">\n        <div className=\"stat-item\">\n          <div className=\"stat-title\">Completion</div>\n          <div className=\"stat-value\">{Math.round(stats.percentageCompleted)}%</div>\n          <div className=\"stat-detail\">\n            {stats.completedWords} / {stats.totalWords} words\n          </div>\n        </div>\n        <div className=\"stat-item\">\n          <div className=\"stat-title\">Accuracy</div>\n          <div className=\"stat-value\">{Math.round(stats.accuracyPercentage)}%</div>\n          <div className=\"stat-detail\">\n            {stats.correctWords} correct words\n          </div>\n        </div>\n        <div className=\"stat-item\">\n          <div className=\"stat-title\">Mistakes</div>\n          <div className=\"stat-value\">\n            {stats.incorrectWords} / {stats.completedWords}\n          </div>\n          <div className=\"stat-detail\">\n            ({stats.completedWords > 0 \n              ? Math.round((stats.incorrectWords / stats.completedWords) * 100) \n              : 0}%)\n          </div>\n        </div>\n        <div className=\"stat-item\">\n          <div className=\"stat-title\">Time</div>\n          <div className=\"stat-value\">{formatTime(totalTime)}</div>\n          <div className=\"stat-detail\">\n            {stats.totalWords > 0 \n              ? Math.round((stats.completedWords / (totalTime / 60)) * 10) / 10\n              : 0} words/min\n          </div>\n        </div>\n      </div>\n      <SentenceByLineComparison />\n      {activeTooltip && (\n        <Tooltip \n          content={tooltipContent}\n          position={tooltipPosition}\n          onClose={() => setActiveTooltip(null)}\n        />\n      )}\n      <button \n        className=\"restart-button\"\n        onClick={onRestart}\n      >\n        New Dictation\n      </button>\n    </div>\n  );\n};\n\nexport default DictationFeedback; ","import React, { useState, useRef, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport AudioPlayer from './AudioPlayer';\nimport ConfirmDialog from './ConfirmDialog';\nimport DictationFeedback from './DictationFeedback';\nimport { \n  alignWords,\n  normalizeText,\n  removePunctuation,\n  isPunctuation,\n  levenshteinDistance,\n  areSimilarWords,\n  isPartOfCompoundWord\n} from '../utils/textUtils';\nimport { debug } from '../utils/debug';\nimport './DictationTool.css';\nimport './mobile/MobileInputArea.css';\n\n// Character-level feedback component with improved word skipping\nconst CharacterFeedback = ({ expected, actual, checkCapitalization = false }) => {\n  // Skip if expected is empty\n  if (!expected) return null;\n  \n  // Initialize with empty string for new behavior\n  if (!actual) actual = '';\n  \n  // Get normalized versions for processing\n  const normalizedExpected = normalizeText(expected, checkCapitalization);\n  \n  // Split expected and actual text into words, removing punctuation\n  const expectedWords = expected.split(/\\s+/);\n  const actualWords = actual.split(/\\s+/);\n  \n  // Find best matching positions for words (allows skipping words)\n  const findBestWordMatches = () => {\n    const result = [];\n    let actualWordIndex = 0;\n    \n    // Process each expected word\n    for (let i = 0; i < expectedWords.length; i++) {\n      const expectedWord = expectedWords[i];\n      const normalizedExpectedWord = normalizeText(expectedWord, checkCapitalization);\n      \n      // If we've run out of actual words, all remaining expected words are missing\n      if (actualWordIndex >= actualWords.length) {\n        result.push({\n          type: 'missing',\n          text: expectedWord\n        });\n      } else {\n        let bestMatch = null;\n        let bestScore = -1;\n        // Increase search ahead to better handle skipped words - look at more candidates\n        let searchAhead = Math.min(5, actualWords.length - actualWordIndex); // Look ahead up to 5 words (increased from 3)\n        \n        // Look ahead a few words to find the best match\n        for (let j = 0; j < searchAhead; j++) {\n          const candidateWord = actualWords[actualWordIndex + j];\n          const normalizedCandidateWord = normalizeText(candidateWord, checkCapitalization);\n          \n          // Calculate match score (0-1)\n          let score = 0;\n          \n          // First check for exact match with proper capitalization handling\n          if (checkCapitalization) {\n            // Normalize both words for umlauts before checking capitalization\n            const normalizedCandidate = normalizeText(candidateWord, true);\n            const normalizedExpected = normalizeText(expectedWord, true);\n            \n            // When checking capitalization, require exact match but with umlaut normalization\n            if (normalizedCandidate === normalizedExpected) {\n              score = 1;\n            }\n            // Special case when case is different but spelling is similar\n            // This handles proper nouns like \"Berlin\" and sentence-initial words like \"Es\"\n            else if (normalizedCandidate.toLowerCase() === normalizedExpected.toLowerCase()) {\n              // Check if expected word is capitalized (proper noun or sentence start)\n              if (expectedWord.charAt(0) === expectedWord.charAt(0).toUpperCase() && \n                  candidateWord.charAt(0) !== candidateWord.charAt(0).toUpperCase()) {\n                score = 0.75; // Lower score for capitalization error\n              } else {\n                score = 0.95; // High score for same word with different case (not first letter)\n              }\n            }\n            // If no exact match but similar spelling, give higher score than usual\n            else if (areSimilarWords(normalizedCandidate.toLowerCase(), normalizedExpected.toLowerCase())) {\n              const dist = levenshteinDistance(normalizedCandidate.toLowerCase(), normalizedExpected.toLowerCase());\n              const longerLength = Math.max(normalizedCandidate.length, normalizedExpected.length);\n              score = 0.6 + 0.3 * (1 - dist / longerLength); // Higher base score in capitalization mode\n            }\n          } else {\n            // When not checking capitalization, compare lowercase versions\n            // Both should already be normalized at this point\n            if (normalizedCandidateWord === normalizedExpectedWord) {\n              score = 1;\n            }\n          }\n          \n          // Check for compound word match (e.g., \"morgen\" in \"Montagmorgen\")\n          if (score < 0.9 && isPartOfCompoundWord(\n            candidateWord,\n            expectedWord\n          )) {\n            // If it's a substring, give it a good but not perfect score\n            score = 0.85;\n          }\n          \n          // Use Levenshtein for similar words\n          if (score < 0.8 && areSimilarWords(\n            checkCapitalization ? expectedWord : normalizedExpectedWord,\n            checkCapitalization ? candidateWord : normalizedCandidateWord\n          )) {\n            // Calculate a score based on normalized Levenshtein distance\n            const dist = levenshteinDistance(\n              checkCapitalization ? expectedWord : normalizedExpectedWord,\n              checkCapitalization ? candidateWord : normalizedCandidateWord\n            );\n            const longerLength = Math.max(\n              (checkCapitalization ? expectedWord : normalizedExpectedWord).length,\n              (checkCapitalization ? candidateWord : normalizedCandidateWord).length\n            );\n            score = 0.5 + 0.4 * (1 - dist / longerLength); // Score between 0.5 and 0.9 for similar words\n          } \n          else if (score < 0.5) {\n            // Less similar words - use character matching as fallback\n            const expectedForCompare = checkCapitalization ? expectedWord : normalizedExpectedWord;\n            const candidateForCompare = checkCapitalization ? candidateWord : normalizedCandidateWord;\n            const minLength = Math.min(expectedForCompare.length, candidateForCompare.length);\n            let matchingChars = 0;\n            \n            for (let k = 0; k < minLength; k++) {\n              if (expectedForCompare[k] === candidateForCompare[k]) {\n                matchingChars++;\n              }\n            }\n            \n            score = matchingChars / Math.max(expectedForCompare.length, candidateForCompare.length);\n          }\n          \n          // Special case for common small words like \"in\", \"ihr\", etc.\n          if (score < 0.8 && \n             (expectedWord.toLowerCase() === 'in' || \n              expectedWord.toLowerCase() === 'ihr' || \n              expectedWord.toLowerCase() === 'ist' || \n              expectedWord.toLowerCase() === 'es' ||\n              expectedWord.toLowerCase() === 'der' ||\n              expectedWord.toLowerCase() === 'die' ||\n              expectedWord.toLowerCase() === 'das')) {\n            // For these common short words, be more lenient with the exact match \n            if (candidateWord.toLowerCase() === expectedWord.toLowerCase()) {\n              score = 0.95; // Nearly perfect match for common small words\n            }\n          }\n          \n          // Apply a position penalty for words that are far away from their expected position\n          // This helps maintain proper word order when words are skipped\n          if (score > 0.4) {\n            // Reduced penalty when checking capitalization is enabled\n            // This helps words like \"balin\" match with \"Berlin\" even with capitalization check\n            const positionPenalty = checkCapitalization ? \n              j * 0.01 : // Only 1% penalty per position when checkCapitalization is true\n              j * 0.03;  // Regular 3% penalty otherwise\n            score = Math.max(0.4, score - positionPenalty);\n          }\n          \n          // Track best match found\n          if (score > bestScore) {\n            bestScore = score;\n            bestMatch = { \n              index: actualWordIndex + j, \n              word: candidateWord,\n              score: score\n            };\n          }\n          \n          // If we found a perfect match, stop looking\n          if (score > 0.95) break;\n        }\n        \n        // Lower the threshold for words that are likely misspellings\n        const similarityThreshold = 0.38; // Lowered from 0.4 to be more lenient\n        \n        // If we found a good enough match\n        if (bestMatch && bestMatch.score > similarityThreshold) {\n          // Add any skipped words as extras - but ONLY in expected words positions\n          for (let j = actualWordIndex; j < bestMatch.index; j++) {\n            // Only add if we're still within expected words range\n            if (result.length < expectedWords.length * 2 - 1) { // Account for spaces\n              result.push({\n                type: 'extra',\n                text: actualWords[j]\n              });\n              \n              // Add a space after each extra word (except the last one before the match)\n              if (j < bestMatch.index - 1) {\n                result.push({\n                  type: 'space',\n                  text: ' '\n                });\n              }\n            }\n          }\n          \n          // Add the matching word\n          if (bestMatch.score >= 0.9) {\n            result.push({\n              type: 'correct',\n              text: expectedWord\n            });\n          } else {\n            // Partial match - compare character by character\n            result.push({\n              type: 'partial',\n              chars: compareChars(expectedWord, bestMatch.word, checkCapitalization)\n            });\n          }\n          \n          actualWordIndex = bestMatch.index + 1; // Move past this word\n        } else {\n          // No good match found for the expected word - mark as missing\n          result.push({\n            type: 'missing',\n            text: expectedWord\n          });\n          \n          // Don't increment actualWordIndex here, so we can try to match\n          // the same actual word with the next expected word\n        }\n      }\n      \n      // Add space between words except for the last one\n      if (i < expectedWords.length - 1) {\n        result.push({\n          type: 'space',\n          text: ' '\n        });\n      }\n    }\n    \n    // Add any remaining actual words that weren't matched\n    // This ensures words like \"bureau\" are shown even when they don't match any expected word\n    while (actualWordIndex < actualWords.length) {\n      // Add a space before adding the extra word (if not at the beginning)\n      if (result.length > 0 && result[result.length - 1].type !== 'space') {\n        result.push({\n          type: 'space',\n          text: ' '\n        });\n      }\n      \n      // Add the unmatched actual word\n      result.push({\n        type: 'extra',\n        text: actualWords[actualWordIndex]\n      });\n      actualWordIndex++;\n    }\n    \n    return result;\n  };\n  \n  // Helper function to compare characters in partially matching words\n  const compareChars = (expected, actual, checkCase) => {\n    const chars = [];\n    \n    if (!expected || !actual) {\n      debug('COMPARE_CHARS', 'Missing expected or actual text');\n      return chars;\n    }\n    \n    // Special case for when capitalization is enabled but the words match case-insensitively\n    // (e.g., \"bÃ¼ro\" vs \"BÃ¼ro\") - we want to mark just the incorrectly cased characters\n    if (checkCase && expected && actual && expected.toLowerCase() === actual.toLowerCase()) {\n      // Characters match but possibly with different case\n      for (let i = 0; i < actual.length; i++) {\n        const expectedChar = expected[i];\n        const actualChar = actual[i];\n        \n        // Only the case difference should be marked incorrect\n        const isMatch = expectedChar === actualChar;\n        \n        // Special highlighting for first letter capitalization errors (proper nouns, sentence starts)\n        const isFirstLetterCapError = i === 0 && \n                                      expectedChar === expectedChar.toUpperCase() && \n                                      actualChar === actualChar.toLowerCase();\n        \n        chars.push({\n          type: isMatch ? 'char-correct' : (isFirstLetterCapError ? 'char-incorrect' : 'char-incorrect'),\n          text: actualChar\n        });\n      }\n      debug('COMPARE_CHARS', 'Case mismatch only');\n      return chars;\n    }\n    \n    // Check for compound word match first (like \"morgen\" in \"Montagmorgen\")\n    if (expected && actual && expected.toLowerCase().includes(actual.toLowerCase())) {\n      // Find the position where the actual word appears in the expected word\n      const actualLower = actual.toLowerCase();\n      const expectedLower = expected.toLowerCase();\n      const startPos = expectedLower.indexOf(actualLower);\n      \n      // Add placeholders for prefix characters\n      for (let i = 0; i < startPos; i++) {\n        const expectedChar = expected[i];\n        chars.push({\n          type: 'char-placeholder',\n          // Always preserve punctuation characters rather than using underscore\n          text: isPunctuation(expectedChar) ? expectedChar : '_'\n        });\n      }\n      \n      // Add the matched part (with case-sensitivity check if needed)\n      for (let i = 0; i < actual.length; i++) {\n        const expectedChar = expected[startPos + i];\n        const actualChar = actual[i];\n        \n        // When checking capitalization, characters must match exactly\n        // Otherwise, case is ignored\n        const isMatch = checkCase \n          ? expectedChar === actualChar\n          : expectedChar.toLowerCase() === actualChar.toLowerCase();\n        \n        chars.push({\n          type: isMatch ? 'char-correct' : 'char-incorrect',\n          text: actualChar\n        });\n      }\n      \n      // Add placeholders for suffix characters\n      for (let i = startPos + actual.length; i < expected.length; i++) {\n        const expectedChar = expected[i];\n        chars.push({\n          type: 'char-placeholder',\n          // Always preserve punctuation characters rather than using underscore\n          text: isPunctuation(expectedChar) ? expectedChar : '_'\n        });\n      }\n      \n      return chars;\n    }\n    \n    // If actual is in expected (like \"morgen\" in \"Montagmorgen\") in reverse\n    if (expected && actual && actual.toLowerCase().includes(expected.toLowerCase())) {\n      // Find the position where the expected word appears in the actual word\n      const actualLower = actual.toLowerCase();\n      const expectedLower = expected.toLowerCase();\n      const startPos = actualLower.indexOf(expectedLower);\n      \n      // First add any extra characters at the beginning\n      for (let i = 0; i < startPos; i++) {\n        chars.push({\n          type: 'char-extra',\n          text: actual[i]\n        });\n      }\n      \n      // Add the matched part\n      for (let i = 0; i < expected.length; i++) {\n        const expectedChar = expected[i];\n        const actualChar = actual[startPos + i];\n        \n        // Check if characters match (with case sensitivity if needed)\n        const isMatch = checkCase \n          ? expectedChar === actualChar\n          : expectedChar.toLowerCase() === actualChar.toLowerCase();\n        \n        chars.push({\n          type: isMatch ? 'char-correct' : 'char-incorrect',\n          text: actualChar\n        });\n      }\n      \n      // Add any extra characters at the end\n      for (let i = startPos + expected.length; i < actual.length; i++) {\n        chars.push({\n          type: 'char-extra',\n          text: actual[i]\n        });\n      }\n      \n      return chars;\n    }\n    \n    // To avoid issues with capitalization mode, first normalize both strings\n    // but preserve case if needed for capitalization checking\n    const normalizedExpected = normalizeText(expected, checkCase);\n    const normalizedActual = normalizeText(actual, checkCase);\n    \n    // For improved character matching in misspelled words, use a variation\n    // of the Levenshtein algorithm to highlight in-place differences\n    \n    // Work with the original strings but use normalized for comparison\n    const expectedChars = expected.split('');\n    const actualChars = actual.split('');\n    \n    // If one of the strings is much longer than the other, try to align them better\n    // This helps with cases where letters were added/omitted in the middle\n    let offsetExpected = 0;\n    let offsetActual = 0;\n    \n    // Compare character by character with dynamic adjustment\n    while (offsetExpected < expectedChars.length) {\n      const charExpected = expectedChars[offsetExpected];\n      \n      // Handle punctuation in the expected text\n      if (isPunctuation(charExpected)) {\n        // If we have an exact match for punctuation, mark it correct\n        if (offsetActual < actualChars.length && charExpected === actualChars[offsetActual]) {\n          chars.push({\n            type: 'char-correct',\n            text: charExpected\n          });\n          offsetActual++; // Move both pointers\n        } else {\n          // Missing punctuation - always show the actual punctuation character\n          chars.push({\n            type: 'char-placeholder',\n            text: charExpected // Always display the punctuation character, never underscore\n          });\n        }\n        offsetExpected++;\n        continue;\n      }\n      \n      // If we've reached the end of the actual text\n      if (offsetActual >= actualChars.length) {\n        // User hasn't typed this character yet\n        const expectedChar = expectedChars[offsetExpected];\n        chars.push({\n          type: 'char-placeholder',\n          // Always preserve punctuation characters rather than using underscore\n          text: isPunctuation(expectedChar) ? expectedChar : '_'\n        });\n        offsetExpected++;\n        continue;\n      }\n      \n      const charActual = actualChars[offsetActual];\n      \n      // If actual char is punctuation but expected is not\n      if (isPunctuation(charActual)) {\n        chars.push({\n          type: 'char-incorrect',\n          text: charActual\n        });\n        offsetActual++;\n        continue;\n      }\n      \n      // When checkCase is true, require EXACT case match of every character\n      const isCharCorrect = checkCase\n        ? charExpected === charActual  // Exact match including case\n        : charExpected.toLowerCase() === charActual.toLowerCase();  // Case-insensitive match\n        \n      if (isCharCorrect) {\n        // Correct character\n        chars.push({\n          type: 'char-correct',\n          text: charActual \n        });\n        offsetExpected++;\n        offsetActual++;\n      } else {\n        // Look ahead for potential alignment\n        const lookAheadLimit = 3;\n        let foundMatch = false;\n        \n        // Check if we can find this expected character later in the actual text\n        for (let i = 1; i <= lookAheadLimit && offsetActual + i < actualChars.length; i++) {\n          if ((checkCase && expectedChars[offsetExpected] === actualChars[offsetActual + i]) ||\n              (!checkCase && expectedChars[offsetExpected].toLowerCase() === actualChars[offsetActual + i].toLowerCase())) {\n            // Found a match ahead, mark characters in between as incorrect\n            for (let j = 0; j < i; j++) {\n              chars.push({\n                type: 'char-incorrect',\n                text: actualChars[offsetActual + j]\n              });\n            }\n            offsetActual += i;\n            foundMatch = true;\n            break;\n          }\n        }\n        \n        // If no match found ahead in actual text, check if character was omitted \n        if (!foundMatch) {\n          // See if next actual character matches with a later expected character\n          for (let i = 1; i <= lookAheadLimit && offsetExpected + i < expectedChars.length; i++) {\n            if ((checkCase && expectedChars[offsetExpected + i] === actualChars[offsetActual]) || \n                (!checkCase && expectedChars[offsetExpected + i].toLowerCase() === actualChars[offsetActual].toLowerCase())) {\n              // Found a match later in expected - user omitted characters\n              for (let j = 0; j < i; j++) {\n                chars.push({\n                  type: 'char-placeholder',\n                  text: '_'\n                });\n                offsetExpected++;\n              }\n              foundMatch = true;\n              break;\n            }\n          }\n        }\n        \n        // If still no alignment found, just mark as incorrect and move both pointers\n        if (!foundMatch) {\n          chars.push({\n            type: 'char-incorrect',\n            text: charActual\n          });\n          offsetActual++;\n          offsetExpected++;\n        }\n      }\n    }\n    \n    // Add any remaining actual characters as extra\n    while (offsetActual < actualChars.length) {\n      chars.push({\n        type: 'char-extra',\n        text: actualChars[offsetActual]\n      });\n      offsetActual++;\n    }\n    \n    return chars;\n  };\n  \n  const diff = findBestWordMatches();\n  \n  return (\n    <div className=\"character-feedback\">\n      {diff.map((item, index) => {\n        switch (item.type) {\n          case 'correct':\n            return (\n              <span key={index} className=\"word-correct\">\n                {item.text}\n              </span>\n            );\n          case 'partial':\n            return (\n              <span key={index} className=\"word-partial\">\n                {item.chars.map((char, charIndex) => {\n                  switch (char.type) {\n                    case 'char-correct':\n                      return <span key={charIndex} className=\"char-correct\">{char.text}</span>;\n                    case 'char-incorrect':\n                      return <span key={charIndex} className=\"char-incorrect\">{char.text}</span>;\n                    case 'char-placeholder':\n                      return <span key={charIndex} className=\"char-placeholder\">{char.text}</span>;\n                    case 'char-extra':\n                      return <span key={charIndex} className=\"char-extra\">{char.text}</span>;\n                    default:\n                      return null;\n                  }\n                })}\n              </span>\n            );\n          case 'missing':\n            return (\n              <span key={index} className=\"word-missing\">\n                {/* Show underscores for missing words - match exact length */}\n                {'_'.repeat(removePunctuation(item.text).length)}\n              </span>\n            );\n          case 'extra':\n            // Always show extra words\n            const needsSpace = index > 0 && diff[index-1]?.type !== 'space';\n            return (\n              <span key={index} className=\"word-extra\">\n                {needsSpace && ' '}{item.text}\n              </span>\n            );\n          case 'space':\n            return (\n              <span key={index} className=\"word-space\">\n                {item.text}\n              </span>\n            );\n          default:\n            return null;\n        }\n      })}\n    </div>\n  );\n};\n\n// Progress indicator component with adaptive display\nconst ProgressIndicator = ({ total, completed, current }) => {\n  // Maximum number of dots to display\n  const MAX_DOTS = 15;\n  \n  // Determine if we need to group sentences\n  const needsGrouping = total > MAX_DOTS;\n  \n  // Calculate how many sentences each dot represents when grouping\n  const groupRatio = needsGrouping ? Math.ceil(total / MAX_DOTS) : 1;\n  \n  // Create the array of dots\n  const dots = [];\n  \n  // If grouping, we'll show fewer dots\n  const dotsToShow = needsGrouping ? Math.min(MAX_DOTS, Math.ceil(total / groupRatio)) : total;\n  \n  for (let i = 0; i < dotsToShow; i++) {\n    // Calculate the sentence range this dot represents\n    const startSentence = i * groupRatio;\n    const endSentence = Math.min(startSentence + groupRatio - 1, total - 1);\n    \n    // Determine if this dot includes the current sentence\n    const includesCurrent = startSentence <= current && current <= endSentence;\n    \n    // Determine status class based on completed sentences in this group\n    let statusClass = '';\n    let allCorrect = true;\n    let anyCompleted = false;\n    \n    // Check status of all sentences in this group\n    for (let j = startSentence; j <= endSentence; j++) {\n      if (j < completed.length && completed[j]) {\n        anyCompleted = true;\n        if (!completed[j].isCorrect) {\n          allCorrect = false;\n        }\n      }\n    }\n    \n    // Set status class for this dot\n    if (anyCompleted) {\n      statusClass = allCorrect ? 'correct' : 'incorrect';\n    }\n    \n    // Add current class if this dot includes current sentence\n    if (includesCurrent) {\n      statusClass += ' current';\n    }\n    \n    // Determine the title/tooltip\n    let title;\n    if (startSentence === endSentence) {\n      title = `Sentence ${startSentence + 1}`;\n    } else {\n      title = `Sentences ${startSentence + 1} - ${endSentence + 1}`;\n    }\n    \n    dots.push({\n      index: i,\n      statusClass,\n      title\n    });\n  }\n  \n  return (\n    <div className=\"progress-container\">\n      {dots.map((dot) => (\n        <div \n          key={dot.index} \n          className={`progress-dot ${dot.statusClass}`}\n          title={dot.title}\n        />\n      ))}\n    </div>\n  );\n};\n\n// Updated sample exercise with reference to actual files\nconst SAMPLE_EXERCISES = [\n  {\n    id: 1,\n    title: \"Chapter 1\",\n    audio: \"/audio/chap01.mp3\",\n    vttFile: \"/audio/chap01.vtt\",\n    level: \"Intermediate\"\n  }\n];\n\nconst DictationTool = forwardRef(({ exerciseId = 1, isMobile = false, hideShortcuts = false, audioPlayerOverride = null, customExercise = null }, ref) => {\n  // Find the selected exercise by ID or use the first one as default\n  const defaultExercise = SAMPLE_EXERCISES.find(ex => ex.id === exerciseId) || SAMPLE_EXERCISES[0];\n  const [selectedExercise, setSelectedExercise] = useState(defaultExercise);\n  const [userInput, setUserInput] = useState('');\n  const [sentences, setSentences] = useState([]);\n  const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [sentenceResults, setSentenceResults] = useState([]);\n  const [exerciseStarted, setExerciseStarted] = useState(false);\n  const [isMac, setIsMac] = useState(false);\n  const [navigationInProgress, setNavigationInProgress] = useState(false);\n  const [enterKeyPressCount, setEnterKeyPressCount] = useState(0);\n  const [waitingForInput, setWaitingForInput] = useState(false);\n  const [showFeedback, setShowFeedback] = useState(true);\n  const [showShortcuts, setShowShortcuts] = useState(false);\n  const [checkCapitalization, setCheckCapitalization] = useState(false);\n  \n  // New states for feedback and confirmation\n  const [isConfirmDialogOpen, setIsConfirmDialogOpen] = useState(false);\n  const [showFeedbackScreen, setShowFeedbackScreen] = useState(false);\n  const [dictationTime, setDictationTime] = useState(0);\n  const [dictationStartTime, setDictationStartTime] = useState(null);\n  const [dictationResults, setDictationResults] = useState(null);\n  \n  const audioRef = useRef(null);\n  const inputRef = useRef(null);\n  const timeoutRef = useRef(null);\n  const timerIntervalRef = useRef(null);\n  const currentIndexRef = useRef(0); // Keep track of current index for closures\n\n  // Update the ref whenever state changes\n  useEffect(() => {\n    currentIndexRef.current = currentSentenceIndex;\n  }, [currentSentenceIndex]);\n\n  // Debug console logs for event tracking\n  useEffect(() => {\n    debug('ENTER_KEY', enterKeyPressCount);\n  }, [enterKeyPressCount]);\n\n  // Debug navigation state\n  useEffect(() => {\n    debug('NAVIGATION_STATE', {\n      currentSentenceIndex,\n      navigationInProgress,\n      exerciseStarted,\n      isPlaying,\n      waitingForInput\n    });\n  }, [currentSentenceIndex, navigationInProgress, exerciseStarted, isPlaying, waitingForInput]);\n\n  // Detect platform on component mount\n  useEffect(() => {\n    const isMacPlatform = navigator.platform.includes('Mac');\n    setIsMac(isMacPlatform);\n  }, []);\n\n  // Update exercise if exerciseId prop changes or a customExercise is provided\n  useEffect(() => {\n    if (customExercise) {\n      // If a custom exercise is provided (embedded mode), use it\n      debug('USING_CUSTOM_EXERCISE', customExercise);\n      setSelectedExercise(customExercise);\n    } else {\n      // Otherwise, use the sample exercise based on ID\n      const exercise = SAMPLE_EXERCISES.find(ex => ex.id === exerciseId) || SAMPLE_EXERCISES[0];\n      setSelectedExercise(exercise);\n    }\n  }, [exerciseId, customExercise]);\n\n  // Load VTT file and extract sentences with timing when exercise changes\n  useEffect(() => {\n    setIsLoading(true);\n    setSentences([]);\n    setCurrentSentenceIndex(0);\n    currentIndexRef.current = 0;\n    setUserInput('');\n    setSentenceResults([]);\n    setExerciseStarted(false);\n    setEnterKeyPressCount(0);\n    setWaitingForInput(false);\n    setShowFeedback(false);\n    setShowFeedbackScreen(false);\n    setDictationTime(0);\n    setDictationStartTime(null);\n    \n    fetch(selectedExercise.vttFile)\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok');\n        }\n        return response.text();\n      })\n      .then(vttContent => {\n        const parsedSentences = parseVTTWithTiming(vttContent);\n        setSentences(parsedSentences);\n        setIsLoading(false);\n      })\n      .catch(error => {\n        console.error('Error loading VTT file:', error);\n        setIsLoading(false);\n      });\n  }, [selectedExercise]);\n\n  // Timer effect to track dictation time\n  useEffect(() => {\n    if (exerciseStarted && dictationStartTime && !showFeedbackScreen) {\n      // Clear any existing timer\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n      }\n      \n      // Start the timer interval\n      timerIntervalRef.current = setInterval(() => {\n        const elapsedSeconds = Math.floor((Date.now() - dictationStartTime) / 1000);\n        setDictationTime(elapsedSeconds);\n      }, 1000);\n    }\n    \n    return () => {\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n      }\n    };\n  }, [exerciseStarted, dictationStartTime, showFeedbackScreen]);\n\n  // Cleanup timeouts when component unmounts\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n      }\n    };\n  }, []);\n\n  // Improved focus management for the textarea\n  useEffect(() => {\n    // Focus input when audio stops playing or when exercise starts\n    if (exerciseStarted && inputRef.current) {\n      if (!isPlaying) {\n        // Only focus if the audio has stopped naturally (not from keyboard events)\n        // Use a short timeout to ensure DOM is ready\n        setTimeout(() => {\n          if (inputRef.current && !isPlaying) {\n            inputRef.current.focus();\n            console.log('[FOCUS]', 'Input field focused after audio stopped');\n            setWaitingForInput(true);\n          }\n        }, 100);\n      }\n    }\n  }, [isPlaying, exerciseStarted]);\n\n  // Global keyboard shortcuts\n  useEffect(() => {\n    const handleKeyboardShortcuts = (e) => {\n      // Only apply shortcuts when exercise has started or to start the exercise\n      if (isLoading) return;\n      \n      // Check for appropriate modifier key based on platform\n      // Mac: Command key (metaKey), Windows/Linux: Ctrl key (ctrlKey)\n      const isModifierKeyPressed = isMac ? e.metaKey : e.ctrlKey;\n      \n      if (isModifierKeyPressed) {\n        switch (e.key) {\n          case 'Enter':\n            // Command/Ctrl+Enter: play/pause\n            e.preventDefault();\n            if (isPlaying) {\n              audioRef.current?.pause();\n            } else {\n              if (!exerciseStarted) {\n                // Start exercise if not already started\n                handleStartExercise();\n              } else {\n                playCurrentSentence();\n              }\n            }\n            break;\n          \n          case 'ArrowLeft':\n            // Command/Ctrl+Left: previous sentence\n            e.preventDefault();\n            if (exerciseStarted) {\n              handlePreviousSentence();\n            }\n            break;\n          \n          case 'ArrowRight':\n            // Command/Ctrl+Right: next sentence\n            e.preventDefault();\n            if (exerciseStarted) {\n              // Use a special version that doesn't require input\n              goToNextSentence(true);\n            }\n            break;\n          \n          case 'ArrowUp':\n            // Command/Ctrl+Up: repeat sentence\n            e.preventDefault();\n            if (exerciseStarted) {\n              playCurrentSentence();\n            } else {\n              // Start exercise if not already started\n              handleStartExercise();\n            }\n            break;\n          \n          default:\n            break;\n        }\n      }\n    };\n\n    // Add global keyboard listener\n    document.addEventListener('keydown', handleKeyboardShortcuts);\n    \n    // Clean up\n    return () => {\n      document.removeEventListener('keydown', handleKeyboardShortcuts);\n    };\n  }, [exerciseStarted, isLoading, isPlaying, currentSentenceIndex, isMac, navigationInProgress]);\n\n  // Parse VTT file and extract sentences with timing info\n  const parseVTTWithTiming = (vttContent) => {\n    const lines = vttContent.split('\\n');\n    const parsedSentences = [];\n    let currentSentence = {\n      text: '',\n      startTime: 0,\n      endTime: 0\n    };\n    \n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n      \n      if (line.includes('-->')) {\n        // Extract timing information\n        const times = line.split('-->').map(t => t.trim());\n        const startTime = parseTimeToSeconds(times[0]);\n        const endTime = parseTimeToSeconds(times[1]);\n        \n        currentSentence = {\n          startTime,\n          endTime,\n          text: ''\n        };\n      } \n      else if (line !== '' && line !== 'WEBVTT' && !line.includes('-->')) {\n        // This is the sentence text\n        currentSentence.text = line;\n        \n        parsedSentences.push({ \n          ...currentSentence\n        });\n      }\n    }\n    \n    return parsedSentences;\n  };\n  \n  // Convert VTT time format (00:00:00.000) to seconds\n  const parseTimeToSeconds = (timeStr) => {\n    const parts = timeStr.split(':');\n    let seconds = 0;\n    \n    if (parts.length === 3) {\n      // Format: HH:MM:SS.mmm\n      seconds = parseFloat(parts[0]) * 3600 + \n                parseFloat(parts[1]) * 60 + \n                parseFloat(parts[2]);\n    } else if (parts.length === 2) {\n      // Format: MM:SS.mmm\n      seconds = parseFloat(parts[0]) * 60 + \n                parseFloat(parts[1]);\n    }\n    \n    return seconds;\n  };\n\n  const handleInputChange = (e) => {\n    // Get the raw input value\n    let inputValue = e.target.value;\n    \n    // Apply real-time umlaut transformations\n    inputValue = inputValue\n      // Handle o-umlaut variations\n      .replace(/oe/g, 'Ã¶')\n      .replace(/o\\//g, 'Ã¶')\n      .replace(/o:/g, 'Ã¶')\n      // Handle a-umlaut variations\n      .replace(/ae/g, 'Ã¤')\n      .replace(/a\\//g, 'Ã¤')\n      .replace(/a:/g, 'Ã¤')\n      // Handle u-umlaut variations\n      .replace(/ue/g, 'Ã¼')\n      .replace(/u\\//g, 'Ã¼')\n      .replace(/u:/g, 'Ã¼')\n      // Handle eszett/sharp s\n      .replace(/s\\//g, 'ÃŸ');\n    \n    // Set the transformed input\n    setUserInput(inputValue);\n  };\n\n  const submitInput = () => {\n    // Call the handler directly instead of clicking a button\n    debug('DIRECT_SUBMIT', 'Directly calling handleNextSentence');\n    handleNextSentence();\n  };\n\n  const handleKeyDown = (e) => {\n    // Use the appropriate modifier key based on platform\n    const isModifierKeyPressed = isMac ? e.metaKey : e.ctrlKey;\n    \n    // Only handle key events when we're not playing audio\n    if (isPlaying) {\n      return; // Don't process keypresses while audio is playing\n    }\n    \n    if (e.key === 'Enter' && !isModifierKeyPressed && !navigationInProgress && !isPlaying) {\n      e.preventDefault(); // Prevent default Enter behavior that might trigger audio skip\n      debug('ENTER_KEY_PRESSED', {\n        currentSentenceIndex,\n        userInput,\n        navigationInProgress,\n        isPlaying,\n        waitingForInput\n      });\n      setEnterKeyPressCount(prev => prev + 1);\n      \n      // Try direct submission instead of calling handler\n      submitInput();\n    }\n  };\n\n  // This function plays the sentence at the specified index (or current index if not provided)\n  const playCurrentSentence = (indexOverride = null) => {\n    // Use the override if provided, otherwise use the ref for most up-to-date value\n    const indexToPlay = indexOverride !== null ? indexOverride : currentIndexRef.current;\n    \n    if (sentences.length === 0 || indexToPlay >= sentences.length || navigationInProgress) {\n      return;\n    }\n    \n    // Clear any pending timeouts\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    \n    setWaitingForInput(false);\n    setIsPlaying(true);\n    \n    const currentSentence = sentences[indexToPlay];\n    \n    if (audioRef.current) {\n      debug('PLAY_SENTENCE', \"Playing sentence at index:\", indexToPlay, \"starting at time:\", currentSentence.startTime, \"ending at:\", currentSentence.endTime);\n      \n      try {\n        // Make sure audio is in stopped state first\n        audioRef.current.pause();\n        \n        // Set the current time to the start of the sentence\n        audioRef.current.seekTo(currentSentence.startTime);\n        \n        // Set the end time for the current sentence\n        audioRef.current.setCurrentSentenceEndTime(currentSentence.endTime);\n        \n        // Start playback\n        audioRef.current.play();\n        \n      } catch (error) {\n        console.error(\"Error in audio playback:\", error);\n        setIsPlaying(false);\n      }\n    }\n  };\n\n  // Add a new function to handle repeating the current sentence\n  const repeatCurrentSentence = () => {\n    if (audioRef.current && sentences.length > 0) {\n      const currentSentence = sentences[currentIndexRef.current];\n      if (currentSentence) {\n        // Stop any current playback\n        audioRef.current.pause();\n        \n        // Reset waiting state\n        setWaitingForInput(false);\n        setIsPlaying(true);\n        \n        // Re-seek to start of current sentence and set end time\n        audioRef.current.seekTo(currentSentence.startTime);\n        audioRef.current.setCurrentSentenceEndTime(currentSentence.endTime);\n        \n        // Start playback\n        audioRef.current.play();\n      }\n    }\n  };\n\n  const handlePreviousSentence = () => {\n    if (currentSentenceIndex > 0 && !navigationInProgress) {\n      debug('PREVIOUS_SENTENCE', 'Navigating to previous sentence');\n      setNavigationInProgress(true);\n      setWaitingForInput(false);\n      // Don't hide feedback in real-time mode\n      \n      // Process current input if there is any\n      if (userInput.trim() !== '') {\n        processUserInput();\n      }\n      \n      // Stop any current playback\n      if (audioRef.current && isPlaying) {\n        audioRef.current.pause();\n      }\n      \n      // Clear any pending timeouts\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n      \n      // Store the new index so we can use it immediately\n      const newIndex = currentSentenceIndex - 1;\n      setCurrentSentenceIndex(newIndex);\n      currentIndexRef.current = newIndex;\n      \n      // Give a small delay before playing previous sentence\n      setTimeout(() => {\n        setUserInput('');\n        playCurrentSentence(newIndex); // Pass the index explicitly\n        setNavigationInProgress(false);\n        debug('PREVIOUS_SENTENCE', 'Navigation completed');\n      }, 100);\n    }\n  };\n\n  const processUserInput = () => {\n    debug('PROCESS_INPUT', 'Processing input for sentence', currentSentenceIndex);\n    \n    if (currentSentenceIndex >= sentences.length) return false;\n    \n    // Check current sentence\n    const currentSentence = sentences[currentSentenceIndex];\n    \n    // Clean up expected text (remove punctuation, normalize spaces)\n    const normalizeForComparison = (text, preserveCase = false) => {\n      // First normalize German umlaut alternatives\n      let normalized = text;\n      \n      // Handle common umlaut alternative notations (before punctuation removal)\n      normalized = normalized\n        // Handle o-umlaut variations (prioritize this for \"schoener\" case)\n        .replace(/oe/g, 'Ã¶')\n        .replace(/o\\//g, 'Ã¶')\n        .replace(/o:/g, 'Ã¶')\n        // Handle a-umlaut variations\n        .replace(/ae/g, 'Ã¤')\n        .replace(/a\\//g, 'Ã¤')\n        .replace(/a:/g, 'Ã¤')\n        // Handle u-umlaut variations\n        .replace(/ue/g, 'Ã¼')\n        .replace(/u\\//g, 'Ã¼')\n        .replace(/u:/g, 'Ã¼')\n        // Handle eszett/sharp s\n        .replace(/s\\//g, 'ÃŸ');\n      \n      // Special case for common problematic words\n      if (normalized.toLowerCase() === 'schoener') normalized = 'schÃ¶ner';\n      if (normalized.toLowerCase() === 'schoen') normalized = 'schÃ¶n';\n      if (normalized.toLowerCase() === 'felle') normalized = 'fÃ¤lle';\n      \n      // Then remove punctuation and normalize spaces\n      normalized = normalized\n        .replace(/[^\\p{L}\\p{N}\\s]/gu, '')\n        .replace(/\\s+/g, ' ')\n        .trim();\n      \n      // Only convert to lowercase if we're not checking capitalization\n      if (!preserveCase) {\n        normalized = normalized.toLowerCase();\n      }\n      \n      return normalized;\n    };\n    \n    // If capitalization is enabled, preserve case for comparison\n    const expected = normalizeForComparison(currentSentence.text, checkCapitalization);\n    const actual = normalizeForComparison(userInput, checkCapitalization);\n    \n    // Simple comparison for now - with capitalization settings applied\n    const isCorrect = expected === actual;\n    \n    // Save result\n    const newResults = [...sentenceResults];\n    newResults[currentSentenceIndex] = {\n      expected: currentSentence.text,\n      actual: userInput,\n      isCorrect\n    };\n    setSentenceResults(newResults);\n    \n    debug('PROCESS_INPUT', {\n      expected,\n      actual,\n      isCorrect,\n      resultsLength: newResults.filter(Boolean).length,\n      checkingCapitalization: checkCapitalization\n    });\n    \n    return isCorrect;\n  };\n\n  // Function to go to next sentence without requiring user input (for shortcuts)\n  const goToNextSentence = (fromShortcut = false) => {\n    debug('NEXT_SENTENCE_SHORTCUT', 'Attempting to go to next sentence');\n    \n    if (currentSentenceIndex >= sentences.length - 1 || navigationInProgress) {\n      // If at the last sentence, process input and show feedback\n      if (userInput.trim() !== '') {\n        processUserInput();\n      }\n      prepareResultsData();\n      setShowFeedbackScreen(true);\n      setIsPlaying(false);\n      setCurrentSentenceIndex(sentences.length);\n      return;\n    }\n    \n    setNavigationInProgress(true);\n    setWaitingForInput(false);\n    setShowFeedback(false);\n    \n    // If there's input, process it\n    if (userInput.trim() !== '') {\n      processUserInput();\n    }\n    \n    // Stop any current playback\n    if (audioRef.current && isPlaying) {\n      audioRef.current.pause();\n    }\n    \n    // Clear any pending timeouts\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    \n    // Store the new index so we can use it immediately\n    const newIndex = currentSentenceIndex + 1;\n    setCurrentSentenceIndex(newIndex);\n    currentIndexRef.current = newIndex;\n    \n    // Give a small delay before playing next sentence\n    setTimeout(() => {\n      setUserInput('');\n      playCurrentSentence(newIndex); // Pass the index explicitly\n      setNavigationInProgress(false);\n      console.log('[NEXT SENTENCE SHORTCUT]', 'Navigation completed');\n    }, 100);\n  };\n\n  const handleNextSentence = () => {\n    debug('NEXT_SENTENCE', 'Button clicked/Enter pressed, attempting to go to next sentence', {\n      userInput: userInput.trim(),\n      navigationInProgress,\n      currentSentenceIndex,\n      waitingForInput\n    });\n    \n    // For button clicks and Enter key, don't require waitingForInput state\n    // Only check for navigation in progress and empty input\n    // Enable force processing for first sentence\n    const forceProcess = currentSentenceIndex === 0;\n    \n    // Check if we can proceed\n    if ((userInput.trim() === '' && !forceProcess) || navigationInProgress) {\n      debug('NEXT_SENTENCE', 'Blocked - empty input or navigation in progress', {\n        inputEmpty: userInput.trim() === '',\n        navigationInProgress,\n        forceProcess\n      });\n      return;\n    }\n    \n    // Process user input and save result\n    if (userInput.trim() !== '') {\n      const isCorrect = processUserInput();\n      \n      // Move to next sentence if not at the end\n      if (currentSentenceIndex < sentences.length - 1) {\n        console.log('[NEXT SENTENCE]', 'Moving to next sentence');\n        setNavigationInProgress(true);\n        setWaitingForInput(false);\n        \n        // Stop any current playback\n        if (audioRef.current && isPlaying) {\n          audioRef.current.pause();\n        }\n        \n        // Clear any pending timeouts\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n          timeoutRef.current = null;\n        }\n        \n        // Store the new index so we can use it immediately\n        const newIndex = currentSentenceIndex + 1;\n        setCurrentSentenceIndex(newIndex);\n        currentIndexRef.current = newIndex;\n        \n        // Give a small delay before playing next sentence\n        setTimeout(() => {\n          setUserInput('');\n          playCurrentSentence(newIndex); // Pass the index explicitly\n          setNavigationInProgress(false);\n          console.log('[NEXT SENTENCE]', 'Navigation completed');\n        }, 100);\n      } else {\n        // End of exercise\n        console.log('[NEXT SENTENCE]', 'Exercise completed! (userInput branch)');\n        setWaitingForInput(false);\n        prepareResultsData();\n        setShowFeedbackScreen(true);\n        setCurrentSentenceIndex(sentences.length);\n      }\n      return;\n    }\n    \n    // Move to next sentence if not at the end\n    if (currentSentenceIndex < sentences.length - 1) {\n      console.log('[NEXT SENTENCE]', 'Moving to next sentence (no userInput)');\n      setNavigationInProgress(true);\n      setWaitingForInput(false);\n      \n      // Stop any current playback\n      if (audioRef.current && isPlaying) {\n        audioRef.current.pause();\n      }\n      \n      // Clear any pending timeouts\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n      \n      // Store the new index so we can use it immediately\n      const newIndex = currentSentenceIndex + 1;\n      setCurrentSentenceIndex(newIndex);\n      currentIndexRef.current = newIndex;\n      \n      // Give a small delay before playing next sentence\n      setTimeout(() => {\n        setUserInput('');\n        playCurrentSentence(newIndex); // Pass the index explicitly\n        setNavigationInProgress(false);\n        console.log('[NEXT SENTENCE]', 'Navigation completed (no userInput)');\n      }, 100);\n    } else {\n      // End of exercise\n      console.log('[NEXT SENTENCE]', 'Exercise completed! (no userInput branch)');\n      setWaitingForInput(false);\n      prepareResultsData();\n      setShowFeedbackScreen(true);\n      setCurrentSentenceIndex(sentences.length);\n    }\n  };\n\n  // Modified to handle audio playback with automatic exercise start\n  const handleAudioPlayStateChange = (state) => {\n    if (state === 'playing') {\n      setIsPlaying(true);\n      \n      // If the exercise hasn't started yet, start it now\n      if (!exerciseStarted) {\n        handleStartExercise();\n      }\n    } else if (state === 'paused') {\n      setIsPlaying(false);\n    }\n  };\n  \n  // Extract the startExercise logic into a separate function for reuse\n  const startExercise = () => {\n    debug('START_EXERCISE', 'Starting exercise');\n    \n    if (sentences.length > 0) {\n      setCurrentSentenceIndex(0);\n      currentIndexRef.current = 0;\n      setSentenceResults([]);\n      setUserInput('');\n      setExerciseStarted(true);\n      setEnterKeyPressCount(0);\n      setWaitingForInput(false);\n      \n      // Small delay to ensure state updates before playing\n      setTimeout(() => {\n        if (inputRef.current) {\n          inputRef.current.focus();\n          debug('START_EXERCISE', 'Initial focus set on input field');\n        }\n      }, 100);\n    }\n  };\n\n  // Update the handleStartExercise to use the extracted function\n  const handleStartExercise = () => {\n    startExercise();\n    \n    // Set the start time when exercise begins\n    setDictationStartTime(Date.now());\n    \n    // Small delay to ensure state updates before playing\n    setTimeout(() => {\n      playCurrentSentence(0); // Explicitly play the first sentence\n    }, 100);\n  };\n\n  const handleRestart = () => {\n    debug('RESTART', 'Restarting exercise');\n    \n    // Clear any pending timeouts\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    \n    setCurrentSentenceIndex(0);\n    currentIndexRef.current = 0;\n    setSentenceResults([]);\n    setUserInput('');\n    setIsPlaying(false);\n    setExerciseStarted(false);\n    setNavigationInProgress(false);\n    setEnterKeyPressCount(0);\n    setWaitingForInput(false);\n    setShowFeedback(false);\n  };\n\n  // Toggle shortcuts panel visibility\n  const toggleShortcutsPanel = () => {\n    setShowShortcuts(prev => !prev);\n  };\n\n  // Extra cleanup to ensure audio stops on unmount \n  useEffect(() => {\n    return () => {\n      // Stop any playback and clear timeouts on unmount or prop change\n      if (audioRef.current) {\n        audioRef.current.pause();\n      }\n      \n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    };\n  }, [selectedExercise]);\n\n  // Handler for cancel button click\n  const handleCancelExercise = () => {\n    console.log(\"handleCancelExercise called in DictationTool\");\n    openConfirmDialog();\n  };\n  \n  // Confirm cancel and show results\n  const confirmCancelExercise = () => {\n    debug('CANCEL_EXERCISE', 'confirmCancelExercise called');\n    setIsConfirmDialogOpen(false);\n    // Process current input if there is any\n    if (userInput.trim() !== '') {\n      processUserInput();\n    }\n    // Stop any playback and clear timers\n    if (audioRef.current) {\n      audioRef.current.pause();\n    }\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    if (timerIntervalRef.current) {\n      clearInterval(timerIntervalRef.current);\n      timerIntervalRef.current = null;\n    }\n    // Always prepare results and show feedback screen\n    prepareResultsData();\n    setShowFeedbackScreen(true);\n    setIsPlaying(false);\n  };\n  \n  // Cancel the dialog without canceling exercise\n  const closeConfirmDialog = () => {\n    setIsConfirmDialogOpen(false);\n  };\n  \n  // Prepare data for feedback screen\n  const prepareResultsData = () => {\n    debug('PREPARE_RESULTS_DATA', 'called');\n    // Calculate various statistics for the feedback\n    const totalSentences = sentences.length;\n    // Get all sentences with their results, including empty results for skipped sentences\n    const allSentenceResults = [...sentenceResults];\n    // Ensure we have entries for all sentences (even if user skipped some)\n    while (allSentenceResults.length < sentences.length) {\n      allSentenceResults.push(null);\n    }\n    // Count total words in ALL sentences from the VTT file\n    const referenceWords = sentences\n      .flatMap(sentence => sentence.text.split(/\\s+/).filter(Boolean));\n    const userWords = allSentenceResults\n      .filter(Boolean)\n      .flatMap(result => result.actual.split(/\\s+/).filter(Boolean));\n    // Smart alignment (pass checkCapitalization)\n    const alignment = alignWords(referenceWords, userWords, checkCapitalization);\n    let correct = 0, mistakes = 0, insertions = 0, deletions = 0, substitutions = 0;\n    alignment.forEach(pair => {\n      if (pair.op === 'match') correct++;\n      else if (pair.op === 'sub') { mistakes++; substitutions++; }\n      else if (pair.op === 'ins') { mistakes++; insertions++; }\n      else if (pair.op === 'del') { mistakes++; deletions++; }\n    });\n    const resultsObj = {\n      totalSentences,\n      completedSentences: allSentenceResults.filter(Boolean).length,\n      referenceWords,\n      userWords,\n      correct,\n      mistakes,\n      insertions,\n      deletions,\n      substitutions,\n      totalWordsInAllText: referenceWords.length\n    };\n    debug('SET_DICTATION_RESULTS', resultsObj);\n    setDictationResults(resultsObj);\n  };\n  \n  // Handle restart from feedback screen\n  const handleRestartFromFeedback = () => {\n    setShowFeedbackScreen(false);\n    handleRestart();\n  };\n\n  const isExerciseCompleted = currentSentenceIndex >= sentences.length && exerciseStarted && sentenceResults.length > 0;\n  \n  // If exercise is completed, show the feedback screen\n  useEffect(() => {\n    if (isExerciseCompleted && !showFeedbackScreen) {\n      // Stop timers\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n      }\n      \n      // Prepare results and show feedback\n      prepareResultsData();\n      setShowFeedbackScreen(true);\n    }\n  }, [isExerciseCompleted, showFeedbackScreen]);\n  \n  // Determine keyboard shortcut symbol based on platform\n  const modifierKeySymbol = isMac ? 'âŒ˜' : 'Ctrl';\n  \n  const currentSentence = sentences[currentSentenceIndex];\n  const currentResult = sentenceResults[currentSentenceIndex];\n  \n  // Ensure dictationResults is set when feedback screen is shown\n  useEffect(() => {\n    if (showFeedbackScreen && !dictationResults) {\n      debug('FORCE_PREPARE_RESULTS_DATA', 'useEffect triggered');\n      prepareResultsData();\n    }\n  }, [showFeedbackScreen, dictationResults]);\n\n  useImperativeHandle(ref, () => ({\n    startExercise: handleStartExercise,\n    cancelExercise: handleCancelExercise,\n    handlePreviousSentence: handlePreviousSentence,\n    goToNextSentence: goToNextSentence,\n    repeatCurrentSentence: repeatCurrentSentence,\n    togglePlayPause: togglePlayPause,\n    changePlaybackSpeed: changePlaybackSpeed,\n    getCurrentSpeed: getCurrentSpeed,\n    audioRef: audioRef, // Expose the audioRef directly\n    getAudioElement: () => audioRef.current // Helper method to get the audio element\n  }));\n\n  // Add an explicit direct handler for the AudioPlayer\n  const handleAudioCancel = () => {\n    console.log(\"handleAudioCancel called from AudioPlayer\");\n    openConfirmDialog();\n  };\n\n  // Add event listener for custom cancel event\n  useEffect(() => {\n    const handleCancelEvent = () => {\n      console.log(\"Caught dictationCancel event in DictationTool\");\n      openConfirmDialog();\n    };\n    \n    document.addEventListener('dictationCancel', handleCancelEvent);\n    \n    return () => {\n      document.removeEventListener('dictationCancel', handleCancelEvent);\n    };\n  }, []);\n\n  // Update the openConfirmDialog function to ensure it's defined\n  const openConfirmDialog = () => {\n    console.log(\"openConfirmDialog called\");\n    setIsConfirmDialogOpen(true);\n  };\n\n  const handleSentenceEnded = () => {\n    console.log(\"Audio ended for current sentence\");\n    \n    // Clear any pending timeouts\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    \n    setIsPlaying(false);\n    setWaitingForInput(true);\n    \n    // Ensure input field is enabled and focused when audio stops\n    setTimeout(() => {\n      if (inputRef.current) {\n        inputRef.current.disabled = false;\n        inputRef.current.focus();\n      }\n    }, 100);\n  };\n\n  const togglePlayPause = () => {\n    console.log(\"Toggling play/pause\");\n    if (audioRef.current) {\n      if (isPlaying) {\n        audioRef.current.pause();\n      } else {\n        audioRef.current.play();\n      }\n    }\n  };\n\n  const pauseAudio = () => {\n    console.log(\"Pausing audio\");\n    if (audioRef.current) {\n      audioRef.current.pause();\n    }\n  };\n\n  const changePlaybackSpeed = () => {\n    console.log(\"Changing playback speed\");\n    if (audioRef.current) {\n      const currentSpeed = audioRef.current.playbackRate;\n      if (currentSpeed >= 1.0) {\n        audioRef.current.playbackRate = 0.75;\n      } else if (currentSpeed >= 0.75) {\n        audioRef.current.playbackRate = 0.5;\n      } else {\n        audioRef.current.playbackRate = 1.0;\n      }\n    }\n  };\n\n  const getCurrentSpeed = () => {\n    if (audioRef.current) {\n      return Math.round(audioRef.current.playbackRate * 100);\n    }\n    return 100; // Default\n  };\n\n  if (isLoading) {\n    return <div className=\"loading\">Loading exercise...</div>;\n  }\n\n  // Show feedback screen if completed or canceled\n  if (showFeedbackScreen) {\n    if (!dictationResults) {\n      return <div className=\"loading\">Loading results...</div>;\n    }\n    return (\n      <DictationFeedback \n        dictationResults={dictationResults}\n        sentenceResults={sentenceResults}\n        totalTime={dictationTime}\n        onRestart={handleRestartFromFeedback}\n      />\n    );\n  }\n\n  // TEMP: Manual Show Results button for debugging\n  // Place this just before the return statement\n  return (\n    <div className=\"dictation-tool\">\n      <div className=\"audio-section\">\n        <AudioPlayer \n          audioSrc={selectedExercise.audio} \n          ref={audioRef}\n          onPlayStateChange={handleAudioPlayStateChange}\n          checkCapitalization={checkCapitalization}\n          onToggleCapitalization={() => setCheckCapitalization(prev => !prev)}\n          onEnded={() => handleSentenceEnded()}\n          onPrevious={handlePreviousSentence}\n          onNext={() => goToNextSentence(true)}\n          onCancel={handleAudioCancel} // Use the explicit handler\n          onRepeat={repeatCurrentSentence}\n        />\n      </div>\n      \n      {/* Confirmation Dialog */}\n      <ConfirmDialog \n        isOpen={isConfirmDialogOpen}\n        title=\"End Dictation Exercise\"\n        message=\"Are you sure you want to end this dictation exercise? Your progress will be saved and results will be shown.\"\n        confirmText=\"End Exercise\"\n        cancelText=\"Continue Exercise\"\n        onConfirm={confirmCancelExercise}\n        onCancel={closeConfirmDialog}\n      />\n      \n      {/* Only show shortcuts panel on desktop */}\n      {!hideShortcuts && (\n        <div className=\"keyboard-shortcuts-info\">\n          <button \n            className=\"shortcuts-toggle\"\n            onClick={toggleShortcutsPanel}\n          >\n            Keyboard Shortcuts\n          </button>\n          <div className={`shortcuts-panel ${showShortcuts ? 'show' : ''}`}>\n            <div className=\"shortcut-row\">\n              <div className=\"shortcut-keys\">\n                <kbd>{modifierKeySymbol}</kbd> + <kbd>Enter</kbd>\n              </div>\n              <div className=\"shortcut-description\">: Play/Pause</div>\n            </div>\n            <div className=\"shortcut-row\">\n              <div className=\"shortcut-keys\">\n                <kbd>{modifierKeySymbol}</kbd> + <kbd>â†</kbd>\n              </div>\n              <div className=\"shortcut-description\">: Previous sentence</div>\n            </div>\n            <div className=\"shortcut-row\">\n              <div className=\"shortcut-keys\">\n                <kbd>{modifierKeySymbol}</kbd> + <kbd>â†’</kbd>\n              </div>\n              <div className=\"shortcut-description\">: Next sentence</div>\n            </div>\n            <div className=\"shortcut-row\">\n              <div className=\"shortcut-keys\">\n                <kbd>{modifierKeySymbol}</kbd> + <kbd>â†‘</kbd>\n              </div>\n              <div className=\"shortcut-description\">: Repeat sentence</div>\n            </div>\n          </div>\n        </div>\n      )}\n      \n      {!isExerciseCompleted ? (\n        <div className=\"input-section\">\n          {exerciseStarted ? (\n            <>\n              {/* Real-time character feedback displayed above input */}\n              {currentSentence && (\n                <div className=\"feedback-container real-time\">\n                  <CharacterFeedback \n                    expected={currentSentence.text} \n                    actual={userInput} \n                    checkCapitalization={checkCapitalization}\n                  />\n                </div>\n              )}\n              \n              <div className=\"dictation-input-area\">\n                <textarea\n                  ref={inputRef}\n                  className={`dictation-input ${isPlaying ? 'is-playing' : 'is-waiting'}`}\n                  value={userInput}\n                  onChange={handleInputChange}\n                  onKeyDown={handleKeyDown}\n                  placeholder=\"Type what you hear, then press Enter...\"\n                  disabled={false} // Always enable input\n                  autoFocus\n                />\n              </div>\n            </>\n          ) : (\n            <div className=\"start-section\">\n              <div className=\"start-instructions\">\n                Press play to start\n              </div>\n            </div>\n          )}\n        </div>\n      ) : null}\n    </div>\n  );\n});\n\nexport default DictationTool;","import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { MOBILE_BREAKPOINT } from './constants';\n\n// Create context\nexport const ResponsiveContext = createContext();\n\nexport const ResponsiveProvider = ({ children }) => {\n  // Initial state is based on current window width\n  const [isMobile, setIsMobile] = useState(\n    typeof window !== 'undefined' ? window.innerWidth <= MOBILE_BREAKPOINT : false\n  );\n  \n  // Use media query for more reliable detection\n  useEffect(() => {\n    // Create media query list\n    const mediaQuery = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT}px)`);\n    \n    // Set the initial value\n    setIsMobile(mediaQuery.matches);\n    \n    // Define handler for changes\n    const handleChange = (e) => {\n      setIsMobile(e.matches);\n    };\n    \n    // Add event listener\n    mediaQuery.addEventListener('change', handleChange);\n    \n    // Clean up\n    return () => mediaQuery.removeEventListener('change', handleChange);\n  }, []);\n\n  // Add this to prevent resetting state on orientation change\n  useEffect(() => {\n    // Store the current exercise state in sessionStorage when orientation changes\n    const handleOrientationChange = () => {\n      // Don't reset the app state on orientation change\n      // Just update the device type without reloading\n      setDeviceType({\n        isMobile: window.matchMedia('(max-width: 767px)').matches,\n        isTablet: window.matchMedia('(min-width: 768px) and (max-width: 1023px)').matches,\n        isDesktop: window.matchMedia('(min-width: 1024px)').matches\n      });\n    };\n\n    // Add event listener for orientation change\n    window.addEventListener('orientationchange', handleOrientationChange);\n    \n    // Also listen for resize events which happen during orientation changes\n    window.addEventListener('resize', handleOrientationChange);\n\n    return () => {\n      window.removeEventListener('orientationchange', handleOrientationChange);\n      window.removeEventListener('resize', handleOrientationChange);\n    };\n  }, []);\n  \n  // Provide the context value\n  return (\n    <ResponsiveContext.Provider value={{ isMobile }}>\n      {children}\n    </ResponsiveContext.Provider>\n  );\n};\n\n// Custom hook for using the responsive context\nexport const useResponsive = () => {\n  const context = useContext(ResponsiveContext);\n  if (context === undefined) {\n    throw new Error('useResponsive must be used within a ResponsiveProvider');\n  }\n  return context;\n};\n","export const MOBILE_BREAKPOINT = 768;\nexport const TABLET_BREAKPOINT = 1024; ","import React, { useRef, useEffect } from 'react';\nimport './MobileGestureHandler.css';\n\nexport const MobileGestureHandler = ({ children }) => {\n  const touchStartRef = useRef(null);\n  const lastTouchRef = useRef(null);\n\n  useEffect(() => {\n    const handleTouchStart = (e) => {\n      if (e.touches.length === 1) {\n        touchStartRef.current = {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY,\n          time: Date.now(),\n        };\n        lastTouchRef.current = touchStartRef.current;\n      }\n    };\n\n    const handleTouchMove = (e) => {\n      if (e.touches.length === 1) {\n        lastTouchRef.current = {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY,\n          time: Date.now(),\n        };\n      }\n    };\n\n    const handleTouchEnd = (e) => {\n      if (!touchStartRef.current || !lastTouchRef.current) return;\n      const dx = lastTouchRef.current.x - touchStartRef.current.x;\n      const dy = lastTouchRef.current.y - touchStartRef.current.y;\n      const absDx = Math.abs(dx);\n      const absDy = Math.abs(dy);\n      const minDist = 40; // Minimum px for swipe\n      if (absDx < minDist && absDy < minDist) return;\n      if (absDx > absDy) {\n        // Horizontal swipe\n        if (dx < 0) {\n          // Left swipe: skip audio back\n          window.dispatchEvent(new CustomEvent('mobile-swipe-left'));\n        } else {\n          // Right swipe: skip audio forward\n          window.dispatchEvent(new CustomEvent('mobile-swipe-right'));\n        }\n      } else {\n        // Vertical swipe\n        if (dy < 0) {\n          // Up swipe: repeat\n          window.dispatchEvent(new CustomEvent('mobile-swipe-up'));\n        } else {\n          // Down swipe: cycle speed\n          window.dispatchEvent(new CustomEvent('mobile-swipe-down'));\n        }\n      }\n      touchStartRef.current = null;\n      lastTouchRef.current = null;\n    };\n\n    document.addEventListener('touchstart', handleTouchStart, { passive: true });\n    document.addEventListener('touchmove', handleTouchMove, { passive: true });\n    document.addEventListener('touchend', handleTouchEnd, { passive: true });\n    return () => {\n      document.removeEventListener('touchstart', handleTouchStart);\n      document.removeEventListener('touchmove', handleTouchMove);\n      document.removeEventListener('touchend', handleTouchEnd);\n    };\n  }, []);\n\n  return <div className=\"mobile-gesture-handler\">{children}</div>;\n}; ","import React, { forwardRef, useImperativeHandle, useRef } from 'react';\nimport DictationTool from './DictationTool';\n\nconst DictationToolWithRef = forwardRef(({ customExercise, ...props }, ref) => {\n  const dictationToolRef = useRef(null);\n  \n  // Expose methods to parent components through ref\n  useImperativeHandle(ref, () => ({\n    // Start the exercise\n    startExercise: () => {\n      if (dictationToolRef.current && dictationToolRef.current.startExercise) {\n        dictationToolRef.current.startExercise();\n      }\n    },\n    \n    // Cancel the exercise\n    cancelExercise: () => {\n      console.log(\"Cancel exercise called via ref\");\n      if (dictationToolRef.current && dictationToolRef.current.cancelExercise) {\n        dictationToolRef.current.cancelExercise();\n      }\n    },\n    \n    // Handle navigation - going to next sentence\n    goToNextSentence: (skipInput) => {\n      if (dictationToolRef.current && dictationToolRef.current.goToNextSentence) {\n        dictationToolRef.current.goToNextSentence(skipInput);\n      }\n    },\n    \n    // Handle navigation - going to previous sentence\n    handlePreviousSentence: () => {\n      if (dictationToolRef.current && dictationToolRef.current.handlePreviousSentence) {\n        dictationToolRef.current.handlePreviousSentence();\n      }\n    },\n    \n    // Play the current sentence again\n    repeatCurrentSentence: () => {\n      console.log(\"Repeating current sentence from ref\");\n      if (dictationToolRef.current && dictationToolRef.current.repeatCurrentSentence) {\n        dictationToolRef.current.repeatCurrentSentence();\n      } else if (dictationToolRef.current && dictationToolRef.current.audioRef && \n                dictationToolRef.current.audioRef.current) {\n        // Fallback if method doesn't exist\n        dictationToolRef.current.audioRef.current.currentTime = 0;\n        dictationToolRef.current.audioRef.current.play();\n      }\n    },\n    \n    // Toggle play/pause\n    togglePlayPause: () => {\n      console.log(\"Toggling play/pause from ref\");\n      if (dictationToolRef.current && dictationToolRef.current.togglePlayPause) {\n        dictationToolRef.current.togglePlayPause();\n      } else if (dictationToolRef.current && dictationToolRef.current.audioRef && \n                dictationToolRef.current.audioRef.current) {\n        // Fallback if method doesn't exist\n        const audio = dictationToolRef.current.audioRef.current;\n        if (audio.paused) {\n          audio.play();\n        } else {\n          audio.pause();\n        }\n      }\n    },\n    \n    // Pause audio\n    pauseAudio: () => {\n      if (dictationToolRef.current && dictationToolRef.current.pauseAudio) {\n        dictationToolRef.current.pauseAudio();\n      } else if (dictationToolRef.current && dictationToolRef.current.audioRef && \n                dictationToolRef.current.audioRef.current) {\n        dictationToolRef.current.audioRef.current.pause();\n      }\n    },\n\n    // Change playback speed\n    changePlaybackSpeed: () => {\n      if (dictationToolRef.current && dictationToolRef.current.changePlaybackSpeed) {\n        dictationToolRef.current.changePlaybackSpeed();\n      } else if (dictationToolRef.current && dictationToolRef.current.audioRef && \n                dictationToolRef.current.audioRef.current) {\n        const audio = dictationToolRef.current.audioRef.current;\n        const currentSpeed = audio.playbackRate;\n        if (currentSpeed >= 1.0) audio.playbackRate = 0.75;\n        else if (currentSpeed >= 0.75) audio.playbackRate = 0.5;\n        else audio.playbackRate = 1.0;\n      }\n    },\n\n    // Get current speed\n    getCurrentSpeed: () => {\n      if (dictationToolRef.current && dictationToolRef.current.getCurrentSpeed) {\n        return dictationToolRef.current.getCurrentSpeed();\n      } else if (dictationToolRef.current && dictationToolRef.current.audioRef && \n                dictationToolRef.current.audioRef.current) {\n        const speed = dictationToolRef.current.audioRef.current.playbackRate;\n        return Math.round(speed * 100);\n      }\n      return 100; // Default\n    },\n\n    // Get audio element\n    getAudioElement: () => {\n      if (dictationToolRef.current && dictationToolRef.current.audioRef && \n          dictationToolRef.current.audioRef.current) {\n        return dictationToolRef.current.audioRef.current;\n      }\n      return null;\n    }\n  }));\n\n  return <DictationTool {...props} customExercise={customExercise} ref={dictationToolRef} />;\n});\n\nexport default DictationToolWithRef;","import React, { useState, useEffect, useRef, forwardRef, useImperativeHandle } from 'react';\nimport './MobileAudioPlayer.css';\n\n// Mobile-specific simplified version of the audio player\n// This version has minimal controls (just play, speed, and cancel buttons)\nconst MobileAudioPlayer = forwardRef((props, ref) => {\n  const { \n    audioSrc, \n    onEnded, \n    onPlayStateChange,\n    onCancel = () => {}\n  } = props;\n\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);\n  \n  // Track current sentence boundaries using refs\n  const sentenceEndTimeRef = useRef(null);\n  const sentenceStartTimeRef = useRef(0);\n  const endEventProcessedRef = useRef(false);\n  \n  const audioRef = useRef(null);\n  \n  // Handle audio source change\n  useEffect(() => {\n    setIsPlaying(false);\n    setCurrentTime(0);\n    setDuration(0);\n    setIsLoaded(false);\n    \n    // Reset audio element\n    if (audioRef.current) {\n      audioRef.current.pause();\n      audioRef.current.currentTime = 0;\n      audioRef.current.load();\n    }\n  }, [audioSrc]);\n  \n  // Expose audio methods to parent component - same as desktop version\n  useImperativeHandle(ref, () => ({\n    play: () => {\n      if (audioRef.current && isLoaded) {\n        endEventProcessedRef.current = false;\n        audioRef.current.play();\n      }\n    },\n    pause: () => {\n      if (audioRef.current) {\n        audioRef.current.pause();\n      }\n    },\n    stop: () => {\n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current.currentTime = 0;\n      }\n    },\n    seekTo: (timeInSeconds) => {\n      if (audioRef.current && isLoaded) {\n        sentenceStartTimeRef.current = timeInSeconds;\n        audioRef.current.currentTime = timeInSeconds;\n        setCurrentTime(timeInSeconds);\n        endEventProcessedRef.current = false;\n        return true;\n      }\n      return false;\n    },\n    setCurrentSentenceEndTime: (endTimeInSeconds) => {\n      sentenceEndTimeRef.current = endTimeInSeconds;\n      endEventProcessedRef.current = false;\n      console.log(\"Set sentence end time to:\", endTimeInSeconds);\n    },\n    getCurrentTime: () => {\n      return audioRef.current ? audioRef.current.currentTime : 0;\n    },\n    getDuration: () => {\n      return audioRef.current ? audioRef.current.duration : 0;\n    },\n    repeatSentence: () => {\n      if (audioRef.current && isLoaded) {\n        endEventProcessedRef.current = false;\n        audioRef.current.currentTime = sentenceStartTimeRef.current;\n        \n        if (sentenceEndTimeRef.current === null) {\n          console.warn('No end time set for sentence repeat');\n        }\n        \n        audioRef.current.play();\n        return true;\n      }\n      return false;\n    }\n  }));\n  \n  const handlePlayPause = () => {\n    if (!isLoaded) return;\n    \n    if (isPlaying) {\n      audioRef.current.pause();\n      if (onPlayStateChange) {\n        onPlayStateChange('paused');\n      }\n    } else {\n      // If starting to play, notify parent\n      if (onPlayStateChange) {\n        onPlayStateChange('playing');\n      }\n      \n      // Start playback\n      audioRef.current.play();\n    }\n  };\n  \n  const handleTimeUpdate = () => {\n    if (audioRef.current) {\n      const currentAudioTime = audioRef.current.currentTime;\n      setCurrentTime(currentAudioTime);\n      \n      // Check if we've reached the end of the current sentence\n      if (sentenceEndTimeRef.current !== null && \n          currentAudioTime >= sentenceEndTimeRef.current && \n          !endEventProcessedRef.current) {\n        \n        console.log(\"Reached sentence end time:\", sentenceEndTimeRef.current, \"current time:\", currentAudioTime);\n        \n        // Mark as processed to prevent multiple callbacks\n        endEventProcessedRef.current = true;\n        \n        // Stop playback when we reach the end time\n        audioRef.current.pause();\n        setIsPlaying(false);\n        \n        // Call the onEnded callback to notify parent\n        if (onEnded) {\n          // Reset sentence end time\n          const prevEndTime = sentenceEndTimeRef.current;\n          sentenceEndTimeRef.current = null;\n          \n          // Small delay to ensure state is updated before callback\n          setTimeout(() => {\n            if (audioRef.current && Math.abs(audioRef.current.currentTime - prevEndTime) < 0.5) {\n              onEnded();\n            }\n          }, 50);\n        }\n      }\n    }\n  };\n  \n  const handleLoadedMetadata = () => {\n    if (audioRef.current) {\n      setDuration(audioRef.current.duration);\n      setIsLoaded(true);\n    }\n  };\n  \n  const handleAudioEnded = () => {\n    setIsPlaying(false);\n    \n    // Ensure playback is truly stopped\n    if (audioRef.current) {\n      audioRef.current.pause();\n    }\n    \n    if (onEnded) {\n      // Small delay to ensure state is updated before callback\n      setTimeout(() => {\n        onEnded();\n      }, 50);\n    }\n  };\n  \n  const handlePlayingState = () => {\n    const playing = audioRef.current && !audioRef.current.paused;\n    setIsPlaying(playing);\n    if (onPlayStateChange) onPlayStateChange(playing);\n  };\n\n  // Fix the cancel button handler\n  const handleCancel = () => {\n    console.log(\"Cancel button clicked in MobileAudioPlayer\");\n    \n    // Try to handle directly\n    if (typeof props.onCancel === 'function') {\n      console.log(\"Calling onCancel from props\");\n      props.onCancel();\n    } else {\n      console.error(\"No onCancel handler provided\");\n      // Try an alternate approach - dispatch a custom event\n      const cancelEvent = new CustomEvent('dictationCancel');\n      document.dispatchEvent(cancelEvent);\n    }\n  };\n  \n  return (\n    <div className=\"mobile-audio-player\">\n      <audio\n        ref={audioRef}\n        src={audioSrc}\n        onTimeUpdate={handleTimeUpdate}\n        onLoadedMetadata={handleLoadedMetadata}\n        onEnded={handleAudioEnded}\n        onPlay={handlePlayingState}\n        onPause={handlePlayingState}\n        loop={false}\n      />\n      \n      <div className=\"mobile-player-container\">\n        {/* Play/pause button */}\n        <button \n          className=\"mobile-play-button\" \n          onClick={handlePlayPause}\n          disabled={!isLoaded}\n        >\n          {isPlaying ? (\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n              <rect x=\"6\" y=\"4\" width=\"4\" height=\"16\" />\n              <rect x=\"14\" y=\"4\" width=\"4\" height=\"16\" />\n            </svg>\n          ) : (\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n              <polygon points=\"5,3 19,12 5,21\" />\n            </svg>\n          )}\n        </button>\n        \n        {/* Speed control button */}\n        <button\n          className=\"mobile-playback-speed-button\"\n          onClick={() => {\n            // Cycle through common playback speeds\n            const speeds = [0.75, 1.0, 1.25, 1.5];\n            const currentIndex = speeds.indexOf(playbackSpeed);\n            const nextIndex = (currentIndex + 1) % speeds.length;\n            setPlaybackSpeed(speeds[nextIndex]);\n            \n            if (audioRef.current) {\n              audioRef.current.playbackRate = speeds[nextIndex];\n            }\n          }}\n        >\n          {playbackSpeed}x\n        </button>\n        \n        {/* Cancel button */}\n        <button \n          className=\"cancel-button\" \n          onClick={handleCancel}\n          title=\"Cancel exercise\"\n        >\n          <span>âœ•</span>\n        </button>\n      </div>\n      \n      {/* Audio progress indicator (minimal) */}\n      <div className=\"mobile-progress-bar\">\n        <div \n          className=\"mobile-progress-fill\" \n          style={{ width: `${(currentTime / duration) * 100 || 0}%` }}\n        ></div>\n      </div>\n    </div>\n  );\n});\n\nexport default MobileAudioPlayer;\n","import React, { useState, useRef, useEffect } from 'react';\nimport DictationToolWithRef from \"../DictationToolWithRef\";\nimport MobileAudioPlayer from './MobileAudioPlayer';\n\n// Inline styles\nconst styles = {\n  container: {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    overflow: 'hidden',\n    width: '100vw',\n    height: '100vh',\n    touchAction: 'none',\n    backgroundColor: '#000'\n  },\n  content: {\n    height: '100%',\n    overflow: 'hidden',\n    display: 'flex',\n    flexDirection: 'column',\n    maxWidth: '100vw',\n    maxHeight: '100vh'\n  },\n  indicators: {\n    position: 'fixed',\n    bottom: '20px',\n    left: 0,\n    right: 0,\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 100,\n    pointerEvents: 'none'\n  },\n  indicator: {\n    display: 'flex',\n    alignItems: 'center',\n    margin: '0 10px',\n    padding: '8px 12px',\n    backgroundColor: 'rgba(0, 0, 0, 0.7)',\n    borderRadius: '20px',\n    color: 'white'\n  },\n  icon: {\n    marginRight: '8px',\n    fontSize: '18px'\n  },\n  feedback: {\n    position: 'fixed',\n    top: '50%',\n    left: '50%',\n    transform: 'translate(-50%, -50%)',\n    backgroundColor: 'rgba(0, 0, 0, 0.8)',\n    color: 'white',\n    padding: '15px 20px',\n    borderRadius: '10px',\n    zIndex: 1000,\n    opacity: 1,\n    pointerEvents: 'none'\n  }\n};\n\nconst MobileDictationTool = (props) => {\n  const [isStarted, setIsStarted] = useState(false);\n  const [swipeFeedback, setSwipeFeedback] = useState(null);\n  const dictationToolRef = useRef(null);\n  const containerRef = useRef(null);\n  const touchStartX = useRef(0);\n  const touchStartY = useRef(0);\n  const minSwipeDistance = 50;\n  const swipeFeedbackTimeoutRef = useRef(null);\n\n  // Function to show swipe feedback\n  const showSwipeFeedback = (message) => {\n    setSwipeFeedback(message);\n    if (swipeFeedbackTimeoutRef.current) {\n      clearTimeout(swipeFeedbackTimeoutRef.current);\n    }\n    swipeFeedbackTimeoutRef.current = setTimeout(() => {\n      setSwipeFeedback(null);\n    }, 1500); // Hide after 1.5 seconds\n  };\n\n  // Prevent default touchmove behavior on container to stop scrolling\n  useEffect(() => {\n    const container = containerRef.current;\n    \n    const preventDefaultScroll = (e) => {\n      // Check if we're on the results screen\n      const resultsScreen = document.querySelector('.dictation-feedback[data-screen=\"results\"]');\n      if (resultsScreen) {\n        // We're on the results screen, allow scrolling\n        return;\n      }\n      \n      // Allow scrolling in textareas\n      let target = e.target;\n      while (target && target !== document) {\n        if (target.tagName && target.tagName.toLowerCase() === 'textarea') {\n          return; // Allow scrolling in textareas\n        }\n        // Also check if we're inside the results/feedback screen\n        if (target.classList && target.classList.contains('dictation-feedback')) {\n          return; // Allow scrolling in feedback screen\n        }\n        target = target.parentNode;\n      }\n      e.preventDefault();\n    };\n    \n    if (container) {\n      container.addEventListener('touchmove', preventDefaultScroll, { passive: false });\n      document.body.addEventListener('touchmove', preventDefaultScroll, { passive: false });\n      \n      // Also prevent scrolling on body\n      document.body.style.overflow = 'hidden';\n      document.documentElement.style.overflow = 'hidden';\n    }\n    \n    return () => {\n      if (container) {\n        container.removeEventListener('touchmove', preventDefaultScroll);\n        document.body.removeEventListener('touchmove', preventDefaultScroll);\n        \n        // Restore scrolling\n        document.body.style.overflow = '';\n        document.documentElement.style.overflow = '';\n      }\n    };\n  }, []);\n\n  // Set up handlers for the dictation tool\n  const handleStartDictation = () => {\n    if (dictationToolRef.current && dictationToolRef.current.startExercise) {\n      dictationToolRef.current.startExercise();\n      setIsStarted(true);\n    }\n  };\n\n  // Handle direct cancel action\n  const handleDirectCancel = () => {\n    console.log(\"Direct cancel handler in MobileDictationTool\");\n    if (dictationToolRef.current && dictationToolRef.current.cancelExercise) {\n      console.log(\"Calling cancelExercise on dictationToolRef\");\n      dictationToolRef.current.cancelExercise();\n    }\n  };\n  \n  // Add swipe gesture handling - works in both orientations\n  useEffect(() => {\n    const container = containerRef.current;\n    \n    const handleTouchStart = (e) => {\n      // Check if we're on the results screen and disable swipe gestures if so\n      const resultsScreen = document.querySelector('.dictation-feedback[data-screen=\"results\"]');\n      if (resultsScreen) {\n        // We're on the results screen, don't track touch positions\n        return;\n      }\n      \n      touchStartX.current = e.touches[0].clientX;\n      touchStartY.current = e.touches[0].clientY;\n    };\n    \n    // Fix swipe directions (right/left were exchanged)\n    const handleTouchEnd = (e) => {\n      if (!e.changedTouches || !e.changedTouches[0]) return;\n      \n      const touchEndX = e.changedTouches[0].clientX;\n      const touchEndY = e.changedTouches[0].clientY;\n      \n      const deltaX = touchEndX - touchStartX.current;\n      const deltaY = touchEndY - touchStartY.current;\n      \n      // Check if we're on the results screen and disable swipe gestures if so\n      const resultsScreen = document.querySelector('.dictation-feedback[data-screen=\"results\"]');\n      if (resultsScreen) {\n        // We're on the results screen, don't process swipe gestures\n        return;\n      }\n      \n      // Check if this is a swipe on a textarea\n      let target = e.target;\n      let isTextarea = false;\n      while (target && target !== document) {\n        if (target.tagName && target.tagName.toLowerCase() === 'textarea') {\n          isTextarea = true;\n          break;\n        }\n        if (!target.parentNode) break;\n        target = target.parentNode;\n      }\n      \n      // Only handle swipes outside of textarea\n      if (!isTextarea) {\n        // Horizontal swipe detection\n        if (Math.abs(deltaX) > Math.abs(deltaY) * 1.5 && Math.abs(deltaX) > minSwipeDistance) {\n          console.log(\"Horizontal swipe detected:\", deltaX > 0 ? \"right\" : \"left\");\n          \n          if (deltaX > 0) {\n            // Swipe right (finger moves right) - Next sentence (FIX: WAS PREVIOUS)\n            console.log(\"Swipe right - next sentence\");\n            if (dictationToolRef.current && typeof dictationToolRef.current.goToNextSentence === 'function') {\n              dictationToolRef.current.goToNextSentence(true);\n              showSwipeFeedback(\"Next sentence\");\n              \n              // Pause audio after navigation\n              if (dictationToolRef.current.pauseAudio) {\n                dictationToolRef.current.pauseAudio();\n              }\n            }\n          } else {\n            // Swipe left (finger moves left) - Previous sentence (FIX: WAS NEXT)\n            console.log(\"Swipe left - previous sentence\");\n            if (dictationToolRef.current && typeof dictationToolRef.current.handlePreviousSentence === 'function') {\n              dictationToolRef.current.handlePreviousSentence();\n              showSwipeFeedback(\"Previous sentence\");\n              \n              // Pause audio after navigation\n              if (dictationToolRef.current.pauseAudio) {\n                dictationToolRef.current.pauseAudio();\n              }\n            }\n          }\n        }\n        \n        // Vertical swipe detection\n        if (Math.abs(deltaY) > Math.abs(deltaX) * 1.5 && Math.abs(deltaY) > minSwipeDistance) {\n          console.log(\"Vertical swipe detected:\", deltaY > 0 ? \"down\" : \"up\");\n          \n          if (deltaY < 0) {\n            // Swipe up (finger moves up) - should repeat current sentence\n            console.log(\"Swipe up - repeat sentence\");\n            if (dictationToolRef.current) {\n              // Log what methods are available on the ref\n              console.log(\"Available methods:\", Object.keys(dictationToolRef.current));\n              \n              // Try to call repeatCurrentSentence with better error handling\n              try {\n                if (typeof dictationToolRef.current.repeatCurrentSentence === 'function') {\n                  dictationToolRef.current.repeatCurrentSentence();\n                  showSwipeFeedback(\"Repeat sentence\");\n                } else if (typeof dictationToolRef.current.audioRef?.current?.play === 'function') {\n                  // Direct fallback to audio element\n                  const audio = dictationToolRef.current.audioRef.current;\n                  audio.currentTime = 0;\n                  audio.play();\n                  showSwipeFeedback(\"Repeat sentence\");\n                } else {\n                  console.error(\"No repeat function available\");\n                }\n              } catch (err) {\n                console.error(\"Error repeating sentence:\", err);\n              }\n            }\n          } else {\n            // Swipe down (finger moves down) - change playback speed\n            console.log(\"Swipe down - change playback speed\");\n            if (dictationToolRef.current) {\n              try {\n                // Directly find the audio element in the DOM for most reliable access\n                const audioElement = document.querySelector('audio');\n                \n                if (audioElement) {\n                  // Get the current playback rate\n                  const currentSpeed = audioElement.playbackRate;\n                  console.log(\"Current audio speed:\", currentSpeed);\n                  let newSpeed;\n                  \n                  // Cycle through speeds with very clear thresholds\n                  if (Math.abs(currentSpeed - 1.0) < 0.1) { // Very close to 1.0\n                    newSpeed = 0.75;\n                    showSwipeFeedback(\"Speed: 75%\");\n                  } else if (Math.abs(currentSpeed - 0.75) < 0.1) { // Very close to 0.75\n                    newSpeed = 0.5;\n                    showSwipeFeedback(\"Speed: 50%\");\n                  } else {\n                    newSpeed = 1.0;\n                    showSwipeFeedback(\"Speed: 100%\");\n                  }\n                  \n                  console.log(\"Setting new speed to:\", newSpeed);\n                  \n                  // Apply the new speed directly to the audio element\n                  audioElement.playbackRate = newSpeed;\n                  \n                  // For debugging - verify the speed was actually changed\n                  setTimeout(() => {\n                    console.log(\"Speed after change:\", audioElement.playbackRate);\n                  }, 100);\n                  \n                  // Also try to set the speed using the method from the ref\n                  if (typeof dictationToolRef.current.changePlaybackSpeed === 'function') {\n                    dictationToolRef.current.changePlaybackSpeed(newSpeed);\n                  }\n                  \n                  // Force a redraw/update by touching the DOM\n                  audioElement.volume = audioElement.volume;\n                } else {\n                  console.error(\"No audio element found in the DOM\");\n                  \n                  // Fallback to using the component method\n                  if (typeof dictationToolRef.current.changePlaybackSpeed === 'function') {\n                    dictationToolRef.current.changePlaybackSpeed();\n                    \n                    // Try to get the speed for display\n                    if (dictationToolRef.current.getCurrentSpeed) {\n                      const speed = dictationToolRef.current.getCurrentSpeed();\n                      showSwipeFeedback(\"Speed: \" + speed + \"%\");\n                    } else {\n                      showSwipeFeedback(\"Speed changed\");\n                    }\n                  }\n                }\n              } catch (err) {\n                console.error(\"Error changing playback speed:\", err);\n              }\n            }\n          }\n        }\n      }\n    };\n    \n    if (container) {\n      container.addEventListener('touchstart', handleTouchStart);\n      container.addEventListener('touchend', handleTouchEnd);\n    }\n    \n    return () => {\n      if (container) {\n        container.removeEventListener('touchstart', handleTouchStart);\n        container.removeEventListener('touchend', handleTouchEnd);\n      }\n    };\n  }, []); // Always active, not just when isStarted\n\n  // Override the audio player with mobile version\n  const injectMobileAudioPlayer = () => {\n    return {\n      component: MobileAudioPlayer,\n      additionalProps: {\n        onStartDictation: handleStartDictation,\n        onCancel: handleDirectCancel\n      }\n    };\n  };\n\n  return (\n    <div className=\"mobile-dictation-container\" ref={containerRef} style={styles.container}>\n      <div className=\"mobile-dictation-content\" style={styles.content}>\n        <DictationToolWithRef \n          {...props}\n          ref={dictationToolRef}\n          audioPlayerOverride={injectMobileAudioPlayer()}\n          isMobile={true}\n          hideShortcuts={true}\n        />\n      </div>\n      \n      {swipeFeedback && (\n        <div style={styles.feedback}>\n          {swipeFeedback}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default MobileDictationTool;\n","// Helper functions for loading external dictation resources for embedded mode\nimport { debug } from './debug';\n\n// Default file paths (for local development/testing)\nconst DEFAULT_RESOURCES = {\n  audio: '/audio/chap01.mp3',\n  vtt: '/audio/chap01.vtt',\n};\n\n/**\n * Loads embedded dictation resources from localStorage (set by embed.html)\n * or uses default local resources if not available\n */\nexport function getEmbeddedResources() {\n  // Check if we're in embedded mode (URL parameters stored in localStorage)\n  const audioUrl = localStorage.getItem('dictation_audioUrl');\n  const vttUrl = localStorage.getItem('dictation_vttUrl');\n  const courseId = localStorage.getItem('dictation_courseId');\n  const lessonId = localStorage.getItem('dictation_lessonId');\n  \n  const isEmbedded = !!(audioUrl && vttUrl);\n  \n  debug('EMBEDDED_RESOURCES', {\n    isEmbedded,\n    audioUrl,\n    vttUrl,\n    courseId,\n    lessonId\n  });\n  \n  // Return resource config\n  return {\n    isEmbedded,\n    audioUrl: audioUrl || DEFAULT_RESOURCES.audio,\n    vttUrl: vttUrl || DEFAULT_RESOURCES.vtt,\n    courseId,\n    lessonId\n  };\n}\n\n/**\n * Parse the VTT file to extract both timing and text content for dictation\n * @param {string} vttUrl - URL to the VTT file\n * @returns {Promise} - Resolves to a dictation exercise object\n */\nexport async function loadDictationFromVtt(vttUrl) {\n  try {\n    // Fetch the VTT file content\n    const response = await fetch(vttUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const vttContent = await response.text();\n    \n    // Parse the VTT file to extract cues and create dictation exercise\n    const sentences = parseVttToSentences(vttContent);\n    \n    return {\n      title: extractTitleFromVtt(vttContent) || \"Dictation Exercise\",\n      audio: getEmbeddedResources().audioUrl,\n      sentences\n    };\n  } catch (error) {\n    console.error(\"Failed to load dictation from VTT:\", error);\n    throw error;\n  }\n}\n\n/**\n * Extract a title from VTT metadata if available\n */\nfunction extractTitleFromVtt(vttContent) {\n  // Look for a NOTE with title in the VTT header\n  const titleMatch = vttContent.match(/NOTE[\\s\\n]+Title:([^\\n]+)/i);\n  if (titleMatch && titleMatch[1]) {\n    return titleMatch[1].trim();\n  }\n  return null;\n}\n\n/**\n * Parse VTT file content to extract sentences with timing\n */\nfunction parseVttToSentences(vttContent) {\n  const lines = vttContent.split('\\n');\n  const sentences = [];\n  let currentIndex = 0;\n  \n  // Skip the WEBVTT header\n  let i = 0;\n  while (i < lines.length && !lines[i].includes('-->')) {\n    i++;\n  }\n  \n  // Process each cue\n  while (i < lines.length) {\n    if (lines[i].includes('-->')) {\n      // This is a timestamp line\n      const times = lines[i].match(/(\\d{2}:\\d{2}:\\d{2}.\\d{3}) --> (\\d{2}:\\d{2}:\\d{2}.\\d{3})/);\n      \n      if (times && times.length >= 3) {\n        const startTime = convertVttTimeToSeconds(times[1]);\n        const endTime = convertVttTimeToSeconds(times[2]);\n        \n        // Get the text content (may span multiple lines)\n        i++;\n        let text = '';\n        while (i < lines.length && lines[i].trim() !== '') {\n          text += lines[i] + ' ';\n          i++;\n        }\n        \n        text = text.trim();\n        \n        if (text) {\n          sentences.push({\n            id: currentIndex++,\n            text,\n            startTime,\n            endTime\n          });\n        }\n      }\n    }\n    i++;\n  }\n  \n  return sentences;\n}\n\n/**\n * Convert VTT timestamp format (00:00:00.000) to seconds\n */\nfunction convertVttTimeToSeconds(vttTime) {\n  const parts = vttTime.split(':');\n  const hours = parseInt(parts[0], 10);\n  const minutes = parseInt(parts[1], 10);\n  const secondsPart = parseFloat(parts[2]);\n  \n  return hours * 3600 + minutes * 60 + secondsPart;\n}\n","import React, { useState, useEffect } from 'react';\nimport { useResponsive } from \"../../responsive/ResponsiveContext\";\nimport { MobileGestureHandler } from \"./MobileGestureHandler\";\nimport DictationToolWithRef from \"../DictationToolWithRef.jsx\";\nimport MobileDictationTool from \"./MobileDictationTool\";\nimport { getEmbeddedResources } from '../../utils/embeddedLoader';\nimport \"./MobileWrapper.css\";\n\nexport const MobileWrapper = ({ embeddedExercise, ...props }) => {\n  const { isMobile } = useResponsive();\n  const [hasStarted, setHasStarted] = useState(false);\n  const { isEmbedded } = getEmbeddedResources();\n\n  useEffect(() => {\n    const trackExerciseStart = () => {\n      setHasStarted(true);\n    };\n    \n    document.addEventListener('exerciseStarted', trackExerciseStart);\n    \n    // If we're in embedded mode, add special handling for Teachable environment\n    if (isEmbedded) {\n      // Notify parent frame (Teachable) that the app is ready\n      if (window.parent && window.parent !== window) {\n        window.parent.postMessage({\n          type: 'DICTATION_APP_READY',\n          height: document.documentElement.scrollHeight\n        }, '*');\n      }\n    }\n    \n    return () => {\n      document.removeEventListener('exerciseStarted', trackExerciseStart);\n    };\n  }, [isEmbedded]);\n\n  // Props to pass to the dictation tool\n  const toolProps = {\n    ...props,\n    customExercise: embeddedExercise // Pass embedded exercise if available\n  };\n\n  if (!isMobile) {\n    return <DictationToolWithRef {...toolProps} isMobile={false} />;\n  }\n\n  return (\n    <div className=\"mobile-wrapper\">\n      <MobileGestureHandler>\n        <MobileDictationTool {...toolProps} isMobile={true} />\n      </MobileGestureHandler>\n    </div>\n  );\n};","import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport DictationTool from './components/DictationTool';\nimport { ResponsiveProvider } from './responsive/ResponsiveContext';\nimport { MobileWrapper } from './components/mobile/MobileWrapper';\nimport { getEmbeddedResources, loadDictationFromVtt } from './utils/embeddedLoader';\nimport { debug } from './utils/debug';\n\nfunction App() {\n  // Default exercise ID - in the future this would be passed from Teachable\n  const defaultExerciseId = 1;\n  const [selectedExerciseId, setSelectedExerciseId] = useState(defaultExerciseId);\n  const [showExerciseSelection, setShowExerciseSelection] = useState(false);\n  const [embeddedExercise, setEmbeddedExercise] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  // Check if we're in embedded mode and load resources\n  useEffect(() => {\n    const resources = getEmbeddedResources();\n    \n    if (resources.isEmbedded) {\n      setIsLoading(true);\n      \n      loadDictationFromVtt(resources.vttUrl)\n        .then(exercise => {\n          debug('EMBEDDED_EXERCISE', exercise);\n          setEmbeddedExercise(exercise);\n          setError(null);\n        })\n        .catch(err => {\n          console.error('Error loading embedded exercise:', err);\n          setError('Failed to load dictation exercise. Please check your connection and try again.');\n        })\n        .finally(() => {\n          setIsLoading(false);\n        });\n    }\n  }, []);\n\n  return (\n    <ResponsiveProvider>\n      <div className=\"app\">\n        <main className=\"app-content\">\n          {isLoading ? (\n            <div className=\"loading\">Loading dictation exercise...</div>\n          ) : error ? (\n            <div className=\"error-message\">{error}</div>\n          ) : (\n            <MobileWrapper \n              exerciseId={selectedExerciseId}\n              embeddedExercise={embeddedExercise}\n              onCancel={() => {\n                console.log(\"Cancel handler from App component\");\n                // Add your app-level cancel logic here\n                // For example, show the exercise selection screen\n                setShowExerciseSelection(true);\n              }}\n            />\n          )}\n        </main>\n      </div>\n    </ResponsiveProvider>\n  );\n}\n\nexport default App;","import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.jsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n) "],"names":["f","require$$0","k","Symbol","for","l","m","Object","prototype","hasOwnProperty","n","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","p","key","ref","__self","__source","q","c","a","g","b","d","e","h","call","defaultProps","$$typeof","type","props","_owner","current","reactJsxRuntime_production_min","jsx","jsxs","jsxRuntimeModule","exports","client","createRoot","hydrateRoot","AudioPlayer","forwardRef","audioSrc","onEnded","onPlayStateChange","checkCapitalization","onToggleCapitalization","onPrevious","onNext","onCancel","onRepeat","isPlaying","setIsPlaying","useState","currentTime","setCurrentTime","duration","setDuration","isLoaded","setIsLoaded","playbackSpeed","setPlaybackSpeed","sentenceEndTimeRef","useRef","sentenceStartTimeRef","endEventProcessedRef","audioRef","progressRef","useEffect","pause","load","reactExports","useImperativeHandle","play","stop","seekTo","timeInSeconds","setCurrentSentenceEndTime","endTimeInSeconds","console","log","getCurrentTime","getDuration","repeatSentence","warn","formatTime","seconds","mins","Math","floor","secs","handlePlayingState","playing","paused","className","children","jsxRuntimeExports","src","onTimeUpdate","currentAudioTime","prevEndTime","setTimeout","abs","onLoadedMetadata","onPlay","onPause","loop","onClick","max","disabled","title","xmlns","width","height","viewBox","fill","stroke","strokeWidth","x","y","points","min","rect","getBoundingClientRect","pos","clientX","left","style","strokeLinecap","strokeLinejoin","newSpeed","playbackRate","preventDefault","stopPropagation","cancelEvent","CustomEvent","document","dispatchEvent","ConfirmDialog","isOpen","message","confirmText","cancelText","onConfirm","Tooltip","content","position","onClose","ReactDOM","createPortal","top","body","DictationFeedback","dictationResults","sentenceResults","totalTime","onRestart","activeTooltip","setActiveTooltip","tooltipPosition","setTooltipPosition","tooltipContent","setTooltipContent","hasUmlautPattern","word","test","calculateSimilarity","word1","word2","normalizedWord1","normalizeGermanText","toLowerCase","normalizedWord2","similarity","levenshteinDistance","length","stats","useMemo","debug","hasDictationResults","sentenceResultsLength","totalSentences","completedSentences","filter","Boolean","totalWords","totalWordsInAllText","completedWords","correctWords","incorrectWords","forEach","result","index","actualWords","actual","split","expectedWords","expected","tempCorrectWords","matchedExpectedIndices","Set","actualWord","i","has","expectedWord","areExactlyEqual","add","percentageCompleted","accuracyPercentage","handleGlobalClick","target","closest","addEventListener","removeEventListener","SentenceByLineComparison","map","sentenceIndex","HighlightedUserSentence","userText","expectedText","wordRefs","userWords","alignment","alignWords","handleWordClick","tooltipId","wordEl","betterMatch","bestMatch","bestScore","findBetterMatchForTooltip","renderElements","pair","idx","displayText","user","isCorrect","op","repeat","color","textDecoration","backgroundColor","_a","el","element","React","Fragment","score","maxHintLevelUsed","round","hintPenaltyMultiplier","CharacterFeedback","normalizeText","compareChars","checkCase","chars","expectedChar","actualChar","isMatch","toUpperCase","push","text","includes","actualLower","startPos","indexOf","isPunctuation","expectedLower","expectedChars","actualChars","offsetExpected","offsetActual","charExpected","charActual","lookAheadLimit","foundMatch","j","diff","actualWordIndex","normalizedExpectedWord","searchAhead","candidateWord","normalizedCandidateWord","normalizedCandidate","normalizedExpected","charAt","areSimilarWords","isPartOfCompoundWord","expectedForCompare","candidateForCompare","minLength","matchingChars","positionPenalty","similarityThreshold","findBestWordMatches","item","char","charIndex","removePunctuation","needsSpace","SAMPLE_EXERCISES","id","audio","vttFile","level","DictationTool","exerciseId","isMobile","hideShortcuts","audioPlayerOverride","customExercise","defaultExercise","find","ex","selectedExercise","setSelectedExercise","userInput","setUserInput","sentences","setSentences","currentSentenceIndex","setCurrentSentenceIndex","isLoading","setIsLoading","setSentenceResults","exerciseStarted","setExerciseStarted","isMac","setIsMac","navigationInProgress","setNavigationInProgress","enterKeyPressCount","setEnterKeyPressCount","waitingForInput","setWaitingForInput","showFeedback","setShowFeedback","showShortcuts","setShowShortcuts","setCheckCapitalization","isConfirmDialogOpen","setIsConfirmDialogOpen","showFeedbackScreen","setShowFeedbackScreen","dictationTime","setDictationTime","dictationStartTime","setDictationStartTime","setDictationResults","inputRef","timeoutRef","timerIntervalRef","currentIndexRef","isMacPlatform","navigator","platform","exercise","fetch","then","response","ok","Error","vttContent","parsedSentences","parseVTTWithTiming","catch","error","clearInterval","setInterval","elapsedSeconds","Date","now","clearTimeout","focus","handleKeyboardShortcuts","metaKey","ctrlKey","goToNextSentence","lines","currentSentence","startTime","endTime","line","trim","times","t","currentSentence2","parseTimeToSeconds","timeStr","parts","parseFloat","playCurrentSentence","indexOverride","indexToPlay","repeatCurrentSentence","handlePreviousSentence","newIndex","processUserInput","normalizeForComparison","preserveCase","normalized","replace","newResults","resultsLength","checkingCapitalization","fromShortcut","handleNextSentence","forceProcess","inputEmpty","handleStartExercise","handleCancelExercise","prepareResultsData","allSentenceResults","referenceWords","flatMap","sentence","correct","mistakes","insertions","deletions","substitutions","resultsObj","handleRestartFromFeedback","isExerciseCompleted","modifierKeySymbol","startExercise","cancelExercise","togglePlayPause","changePlaybackSpeed","getCurrentSpeed","getAudioElement","handleCancelEvent","openConfirmDialog","currentSpeed","state","prev","value","onChange","inputValue","onKeyDown","isModifierKeyPressed","placeholder","autoFocus","ResponsiveContext","createContext","ResponsiveProvider","setIsMobile","window","innerWidth","mediaQuery","matchMedia","matches","handleChange","handleOrientationChange","setDeviceType","isTablet","isDesktop","Provider","MobileGestureHandler","touchStartRef","lastTouchRef","handleTouchStart","touches","clientY","time","handleTouchMove","handleTouchEnd","dx","dy","absDx","absDy","passive","DictationToolWithRef","dictationToolRef","skipInput","pauseAudio","speed","MobileAudioPlayer","speeds","nextIndex","styles","container","right","bottom","overflow","touchAction","display","flexDirection","maxWidth","maxHeight","indicators","justifyContent","alignItems","zIndex","pointerEvents","indicator","margin","padding","borderRadius","icon","marginRight","fontSize","feedback","transform","opacity","MobileDictationTool","isStarted","setIsStarted","swipeFeedback","setSwipeFeedback","containerRef","touchStartX","touchStartY","swipeFeedbackTimeoutRef","showSwipeFeedback","preventDefaultScroll","querySelector","tagName","classList","contains","parentNode","documentElement","handleStartDictation","handleDirectCancel","changedTouches","touchEndX","touchEndY","deltaX","deltaY","isTextarea","keys","_b","err","audioElement","volume","component","additionalProps","onStartDictation","DEFAULT_RESOURCES","getEmbeddedResources","audioUrl","localStorage","getItem","vttUrl","courseId","lessonId","isEmbedded","async","loadDictationFromVtt","status","currentIndex","match","convertVttTimeToSeconds","parseVttToSentences","extractTitleFromVtt","titleMatch","vttTime","parseInt","MobileWrapper","embeddedExercise","context","useContext","useResponsive","hasStarted","setHasStarted","trackExerciseStart","parent","postMessage","scrollHeight","toolProps","App","selectedExerciseId","setSelectedExerciseId","showExerciseSelection","setShowExerciseSelection","setEmbeddedExercise","setError","resources","finally","getElementById","render","StrictMode"],"mappings":"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","x_google_ignoreList":[0,1,2]}